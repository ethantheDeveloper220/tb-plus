/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/isomorphic-git@1.30.1/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import t from"/npm/async-lock@1.4.1/+esm";import e from"/npm/sha.js@2.4.11/sha1.js/+esm";import{join as r}from"/npm/path-browserify@1.0.1/+esm";import i from"/npm/crc-32@1.2.2/+esm";import a from"/npm/pako@1.0.11/+esm";import n from"/npm/pify@4.0.1/+esm";import s from"/npm/ignore@5.3.2/+esm";import o from"/npm/clean-git-ref@2.0.1/+esm";import c from"/npm/diff3@0.0.3/+esm";var f="undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},d=[],h=[],u="undefined"!=typeof Uint8Array?Uint8Array:Array,l=!1;function g(){l=!0;for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",e=0;e<64;++e)d[e]=t[e],h[t.charCodeAt(e)]=e;h["-".charCodeAt(0)]=62,h["_".charCodeAt(0)]=63}function w(t){return d[t>>18&63]+d[t>>12&63]+d[t>>6&63]+d[63&t]}function p(t,e,r){for(var i,a=[],n=e;n<r;n+=3)i=(t[n]<<16)+(t[n+1]<<8)+t[n+2],a.push(w(i));return a.join("")}function m(t){var e;l||g();for(var r=t.length,i=r%3,a="",n=[],s=16383,o=0,c=r-i;o<c;o+=s)n.push(p(t,o,o+s>c?c:o+s));return 1===i?(e=t[r-1],a+=d[e>>2],a+=d[e<<4&63],a+="=="):2===i&&(e=(t[r-2]<<8)+t[r-1],a+=d[e>>10],a+=d[e>>4&63],a+=d[e<<2&63],a+="="),n.push(a),n.join("")}function y(t,e,r,i,a){var n,s,o=8*a-i-1,c=(1<<o)-1,f=c>>1,d=-7,h=r?a-1:0,u=r?-1:1,l=t[e+h];for(h+=u,n=l&(1<<-d)-1,l>>=-d,d+=o;d>0;n=256*n+t[e+h],h+=u,d-=8);for(s=n&(1<<-d)-1,n>>=-d,d+=i;d>0;s=256*s+t[e+h],h+=u,d-=8);if(0===n)n=1-f;else{if(n===c)return s?NaN:1/0*(l?-1:1);s+=Math.pow(2,i),n-=f}return(l?-1:1)*s*Math.pow(2,n-i)}function b(t,e,r,i,a,n){var s,o,c,f=8*n-a-1,d=(1<<f)-1,h=d>>1,u=23===a?Math.pow(2,-24)-Math.pow(2,-77):0,l=i?0:n-1,g=i?1:-1,w=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(o=isNaN(e)?1:0,s=d):(s=Math.floor(Math.log(e)/Math.LN2),e*(c=Math.pow(2,-s))<1&&(s--,c*=2),(e+=s+h>=1?u/c:u*Math.pow(2,1-h))*c>=2&&(s++,c/=2),s+h>=d?(o=0,s=d):s+h>=1?(o=(e*c-1)*Math.pow(2,a),s+=h):(o=e*Math.pow(2,h-1)*Math.pow(2,a),s=0));a>=8;t[r+l]=255&o,l+=g,o/=256,a-=8);for(s=s<<a|o,f+=a;f>0;t[r+l]=255&s,l+=g,s/=256,f-=8);t[r+l-g]|=128*w}var v={}.toString,x=Array.isArray||function(t){return"[object Array]"==v.call(t)};function E(){return $.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function _(t,e){if(E()<e)throw new RangeError("Invalid typed array length");return $.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(e)).__proto__=$.prototype:(null===t&&(t=new $(e)),t.length=e),t}function $(t,e,r){if(!($.TYPED_ARRAY_SUPPORT||this instanceof $))return new $(t,e,r);if("number"==typeof t){if("string"==typeof e)throw new Error("If encoding is specified then the first argument must be a string");return P(this,t)}return S(this,t,e,r)}function S(t,e,r,i){if("number"==typeof e)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer?function(t,e,r,i){if(e.byteLength,r<0||e.byteLength<r)throw new RangeError("'offset' is out of bounds");if(e.byteLength<r+(i||0))throw new RangeError("'length' is out of bounds");e=void 0===r&&void 0===i?new Uint8Array(e):void 0===i?new Uint8Array(e,r):new Uint8Array(e,r,i);$.TYPED_ARRAY_SUPPORT?(t=e).__proto__=$.prototype:t=R(t,e);return t}(t,e,r,i):"string"==typeof e?function(t,e,r){"string"==typeof r&&""!==r||(r="utf8");if(!$.isEncoding(r))throw new TypeError('"encoding" must be a valid string encoding');var i=0|I(e,r);t=_(t,i);var a=t.write(e,r);a!==i&&(t=t.slice(0,a));return t}(t,e,r):function(t,e){if(j(e)){var r=0|k(e.length);return 0===(t=_(t,r)).length||e.copy(t,0,0,r),t}if(e){if("undefined"!=typeof ArrayBuffer&&e.buffer instanceof ArrayBuffer||"length"in e)return"number"!=typeof e.length||(i=e.length)!=i?_(t,0):R(t,e);if("Buffer"===e.type&&x(e.data))return R(t,e.data)}var i;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(t,e)}function A(t){if("number"!=typeof t)throw new TypeError('"size" argument must be a number');if(t<0)throw new RangeError('"size" argument must not be negative')}function P(t,e){if(A(e),t=_(t,e<0?0:0|k(e)),!$.TYPED_ARRAY_SUPPORT)for(var r=0;r<e;++r)t[r]=0;return t}function R(t,e){var r=e.length<0?0:0|k(e.length);t=_(t,r);for(var i=0;i<r;i+=1)t[i]=255&e[i];return t}function k(t){if(t>=E())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+E().toString(16)+" bytes");return 0|t}function j(t){return!(null==t||!t._isBuffer)}function I(t,e){if(j(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;"string"!=typeof t&&(t=""+t);var r=t.length;if(0===r)return 0;for(var i=!1;;)switch(e){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return at(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return nt(t).length;default:if(i)return at(t).length;e=(""+e).toLowerCase(),i=!0}}function O(t,e,r){var i=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(e>>>=0))return"";for(t||(t="utf8");;)switch(t){case"hex":return q(this,e,r);case"utf8":case"utf-8":return z(this,e,r);case"ascii":return Y(this,e,r);case"latin1":case"binary":return G(this,e,r);case"base64":return L(this,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return K(this,e,r);default:if(i)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),i=!0}}function T(t,e,r){var i=t[e];t[e]=t[r],t[r]=i}function B(t,e,r,i,a){if(0===t.length)return-1;if("string"==typeof r?(i=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=a?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(a)return-1;r=t.length-1}else if(r<0){if(!a)return-1;r=0}if("string"==typeof e&&(e=$.from(e,i)),j(e))return 0===e.length?-1:U(t,e,r,i,a);if("number"==typeof e)return e&=255,$.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?a?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):U(t,[e],r,i,a);throw new TypeError("val must be string, number or Buffer")}function U(t,e,r,i,a){var n,s=1,o=t.length,c=e.length;if(void 0!==i&&("ucs2"===(i=String(i).toLowerCase())||"ucs-2"===i||"utf16le"===i||"utf-16le"===i)){if(t.length<2||e.length<2)return-1;s=2,o/=2,c/=2,r/=2}function f(t,e){return 1===s?t[e]:t.readUInt16BE(e*s)}if(a){var d=-1;for(n=r;n<o;n++)if(f(t,n)===f(e,-1===d?0:n-d)){if(-1===d&&(d=n),n-d+1===c)return d*s}else-1!==d&&(n-=n-d),d=-1}else for(r+c>o&&(r=o-c),n=r;n>=0;n--){for(var h=!0,u=0;u<c;u++)if(f(t,n+u)!==f(e,u)){h=!1;break}if(h)return n}return-1}function C(t,e,r,i){r=Number(r)||0;var a=t.length-r;i?(i=Number(i))>a&&(i=a):i=a;var n=e.length;if(n%2!=0)throw new TypeError("Invalid hex string");i>n/2&&(i=n/2);for(var s=0;s<i;++s){var o=parseInt(e.substr(2*s,2),16);if(isNaN(o))return s;t[r+s]=o}return s}function D(t,e,r,i){return st(at(e,t.length-r),t,r,i)}function M(t,e,r,i){return st(function(t){for(var e=[],r=0;r<t.length;++r)e.push(255&t.charCodeAt(r));return e}(e),t,r,i)}function N(t,e,r,i){return M(t,e,r,i)}function F(t,e,r,i){return st(nt(e),t,r,i)}function H(t,e,r,i){return st(function(t,e){for(var r,i,a,n=[],s=0;s<t.length&&!((e-=2)<0);++s)i=(r=t.charCodeAt(s))>>8,a=r%256,n.push(a),n.push(i);return n}(e,t.length-r),t,r,i)}function L(t,e,r){return 0===e&&r===t.length?m(t):m(t.slice(e,r))}function z(t,e,r){r=Math.min(t.length,r);for(var i=[],a=e;a<r;){var n,s,o,c,f=t[a],d=null,h=f>239?4:f>223?3:f>191?2:1;if(a+h<=r)switch(h){case 1:f<128&&(d=f);break;case 2:128==(192&(n=t[a+1]))&&(c=(31&f)<<6|63&n)>127&&(d=c);break;case 3:n=t[a+1],s=t[a+2],128==(192&n)&&128==(192&s)&&(c=(15&f)<<12|(63&n)<<6|63&s)>2047&&(c<55296||c>57343)&&(d=c);break;case 4:n=t[a+1],s=t[a+2],o=t[a+3],128==(192&n)&&128==(192&s)&&128==(192&o)&&(c=(15&f)<<18|(63&n)<<12|(63&s)<<6|63&o)>65535&&c<1114112&&(d=c)}null===d?(d=65533,h=1):d>65535&&(d-=65536,i.push(d>>>10&1023|55296),d=56320|1023&d),i.push(d),a+=h}return function(t){var e=t.length;if(e<=W)return String.fromCharCode.apply(String,t);var r="",i=0;for(;i<e;)r+=String.fromCharCode.apply(String,t.slice(i,i+=W));return r}(i)}$.TYPED_ARRAY_SUPPORT=void 0===f.TYPED_ARRAY_SUPPORT||f.TYPED_ARRAY_SUPPORT,E(),$.poolSize=8192,$._augment=function(t){return t.__proto__=$.prototype,t},$.from=function(t,e,r){return S(null,t,e,r)},$.TYPED_ARRAY_SUPPORT&&($.prototype.__proto__=Uint8Array.prototype,$.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&$[Symbol.species]),$.alloc=function(t,e,r){return function(t,e,r,i){return A(e),e<=0?_(t,e):void 0!==r?"string"==typeof i?_(t,e).fill(r,i):_(t,e).fill(r):_(t,e)}(null,t,e,r)},$.allocUnsafe=function(t){return P(null,t)},$.allocUnsafeSlow=function(t){return P(null,t)},$.isBuffer=function(t){return null!=t&&(!!t._isBuffer||ot(t)||function(t){return"function"==typeof t.readFloatLE&&"function"==typeof t.slice&&ot(t.slice(0,0))}(t))},$.compare=function(t,e){if(!j(t)||!j(e))throw new TypeError("Arguments must be Buffers");if(t===e)return 0;for(var r=t.length,i=e.length,a=0,n=Math.min(r,i);a<n;++a)if(t[a]!==e[a]){r=t[a],i=e[a];break}return r<i?-1:i<r?1:0},$.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},$.concat=function(t,e){if(!x(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return $.alloc(0);var r;if(void 0===e)for(e=0,r=0;r<t.length;++r)e+=t[r].length;var i=$.allocUnsafe(e),a=0;for(r=0;r<t.length;++r){var n=t[r];if(!j(n))throw new TypeError('"list" argument must be an Array of Buffers');n.copy(i,a),a+=n.length}return i},$.byteLength=I,$.prototype._isBuffer=!0,$.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var e=0;e<t;e+=2)T(this,e,e+1);return this},$.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var e=0;e<t;e+=4)T(this,e,e+3),T(this,e+1,e+2);return this},$.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var e=0;e<t;e+=8)T(this,e,e+7),T(this,e+1,e+6),T(this,e+2,e+5),T(this,e+3,e+4);return this},$.prototype.toString=function(){var t=0|this.length;return 0===t?"":0===arguments.length?z(this,0,t):O.apply(this,arguments)},$.prototype.equals=function(t){if(!j(t))throw new TypeError("Argument must be a Buffer");return this===t||0===$.compare(this,t)},$.prototype.inspect=function(){var t="";return this.length>0&&(t=this.toString("hex",0,50).match(/.{2}/g).join(" "),this.length>50&&(t+=" ... ")),"<Buffer "+t+">"},$.prototype.compare=function(t,e,r,i,a){if(!j(t))throw new TypeError("Argument must be a Buffer");if(void 0===e&&(e=0),void 0===r&&(r=t?t.length:0),void 0===i&&(i=0),void 0===a&&(a=this.length),e<0||r>t.length||i<0||a>this.length)throw new RangeError("out of range index");if(i>=a&&e>=r)return 0;if(i>=a)return-1;if(e>=r)return 1;if(this===t)return 0;for(var n=(a>>>=0)-(i>>>=0),s=(r>>>=0)-(e>>>=0),o=Math.min(n,s),c=this.slice(i,a),f=t.slice(e,r),d=0;d<o;++d)if(c[d]!==f[d]){n=c[d],s=f[d];break}return n<s?-1:s<n?1:0},$.prototype.includes=function(t,e,r){return-1!==this.indexOf(t,e,r)},$.prototype.indexOf=function(t,e,r){return B(this,t,e,r,!0)},$.prototype.lastIndexOf=function(t,e,r){return B(this,t,e,r,!1)},$.prototype.write=function(t,e,r,i){if(void 0===e)i="utf8",r=this.length,e=0;else if(void 0===r&&"string"==typeof e)i=e,r=this.length,e=0;else{if(!isFinite(e))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");e|=0,isFinite(r)?(r|=0,void 0===i&&(i="utf8")):(i=r,r=void 0)}var a=this.length-e;if((void 0===r||r>a)&&(r=a),t.length>0&&(r<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");i||(i="utf8");for(var n=!1;;)switch(i){case"hex":return C(this,t,e,r);case"utf8":case"utf-8":return D(this,t,e,r);case"ascii":return M(this,t,e,r);case"latin1":case"binary":return N(this,t,e,r);case"base64":return F(this,t,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return H(this,t,e,r);default:if(n)throw new TypeError("Unknown encoding: "+i);i=(""+i).toLowerCase(),n=!0}},$.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var W=4096;function Y(t,e,r){var i="";r=Math.min(t.length,r);for(var a=e;a<r;++a)i+=String.fromCharCode(127&t[a]);return i}function G(t,e,r){var i="";r=Math.min(t.length,r);for(var a=e;a<r;++a)i+=String.fromCharCode(t[a]);return i}function q(t,e,r){var i=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>i)&&(r=i);for(var a="",n=e;n<r;++n)a+=it(t[n]);return a}function K(t,e,r){for(var i=t.slice(e,r),a="",n=0;n<i.length;n+=2)a+=String.fromCharCode(i[n]+256*i[n+1]);return a}function V(t,e,r){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(t+e>r)throw new RangeError("Trying to access beyond buffer length")}function Z(t,e,r,i,a,n){if(!j(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>a||e<n)throw new RangeError('"value" argument is out of bounds');if(r+i>t.length)throw new RangeError("Index out of range")}function J(t,e,r,i){e<0&&(e=65535+e+1);for(var a=0,n=Math.min(t.length-r,2);a<n;++a)t[r+a]=(e&255<<8*(i?a:1-a))>>>8*(i?a:1-a)}function X(t,e,r,i){e<0&&(e=4294967295+e+1);for(var a=0,n=Math.min(t.length-r,4);a<n;++a)t[r+a]=e>>>8*(i?a:3-a)&255}function Q(t,e,r,i,a,n){if(r+i>t.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function tt(t,e,r,i,a){return a||Q(t,0,r,4),b(t,e,r,i,23,4),r+4}function et(t,e,r,i,a){return a||Q(t,0,r,8),b(t,e,r,i,52,8),r+8}$.prototype.slice=function(t,e){var r,i=this.length;if((t=~~t)<0?(t+=i)<0&&(t=0):t>i&&(t=i),(e=void 0===e?i:~~e)<0?(e+=i)<0&&(e=0):e>i&&(e=i),e<t&&(e=t),$.TYPED_ARRAY_SUPPORT)(r=this.subarray(t,e)).__proto__=$.prototype;else{var a=e-t;r=new $(a,void 0);for(var n=0;n<a;++n)r[n]=this[n+t]}return r},$.prototype.readUIntLE=function(t,e,r){t|=0,e|=0,r||V(t,e,this.length);for(var i=this[t],a=1,n=0;++n<e&&(a*=256);)i+=this[t+n]*a;return i},$.prototype.readUIntBE=function(t,e,r){t|=0,e|=0,r||V(t,e,this.length);for(var i=this[t+--e],a=1;e>0&&(a*=256);)i+=this[t+--e]*a;return i},$.prototype.readUInt8=function(t,e){return e||V(t,1,this.length),this[t]},$.prototype.readUInt16LE=function(t,e){return e||V(t,2,this.length),this[t]|this[t+1]<<8},$.prototype.readUInt16BE=function(t,e){return e||V(t,2,this.length),this[t]<<8|this[t+1]},$.prototype.readUInt32LE=function(t,e){return e||V(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},$.prototype.readUInt32BE=function(t,e){return e||V(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},$.prototype.readIntLE=function(t,e,r){t|=0,e|=0,r||V(t,e,this.length);for(var i=this[t],a=1,n=0;++n<e&&(a*=256);)i+=this[t+n]*a;return i>=(a*=128)&&(i-=Math.pow(2,8*e)),i},$.prototype.readIntBE=function(t,e,r){t|=0,e|=0,r||V(t,e,this.length);for(var i=e,a=1,n=this[t+--i];i>0&&(a*=256);)n+=this[t+--i]*a;return n>=(a*=128)&&(n-=Math.pow(2,8*e)),n},$.prototype.readInt8=function(t,e){return e||V(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},$.prototype.readInt16LE=function(t,e){e||V(t,2,this.length);var r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},$.prototype.readInt16BE=function(t,e){e||V(t,2,this.length);var r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},$.prototype.readInt32LE=function(t,e){return e||V(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},$.prototype.readInt32BE=function(t,e){return e||V(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},$.prototype.readFloatLE=function(t,e){return e||V(t,4,this.length),y(this,t,!0,23,4)},$.prototype.readFloatBE=function(t,e){return e||V(t,4,this.length),y(this,t,!1,23,4)},$.prototype.readDoubleLE=function(t,e){return e||V(t,8,this.length),y(this,t,!0,52,8)},$.prototype.readDoubleBE=function(t,e){return e||V(t,8,this.length),y(this,t,!1,52,8)},$.prototype.writeUIntLE=function(t,e,r,i){(t=+t,e|=0,r|=0,i)||Z(this,t,e,r,Math.pow(2,8*r)-1,0);var a=1,n=0;for(this[e]=255&t;++n<r&&(a*=256);)this[e+n]=t/a&255;return e+r},$.prototype.writeUIntBE=function(t,e,r,i){(t=+t,e|=0,r|=0,i)||Z(this,t,e,r,Math.pow(2,8*r)-1,0);var a=r-1,n=1;for(this[e+a]=255&t;--a>=0&&(n*=256);)this[e+a]=t/n&255;return e+r},$.prototype.writeUInt8=function(t,e,r){return t=+t,e|=0,r||Z(this,t,e,1,255,0),$.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[e]=255&t,e+1},$.prototype.writeUInt16LE=function(t,e,r){return t=+t,e|=0,r||Z(this,t,e,2,65535,0),$.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):J(this,t,e,!0),e+2},$.prototype.writeUInt16BE=function(t,e,r){return t=+t,e|=0,r||Z(this,t,e,2,65535,0),$.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):J(this,t,e,!1),e+2},$.prototype.writeUInt32LE=function(t,e,r){return t=+t,e|=0,r||Z(this,t,e,4,4294967295,0),$.TYPED_ARRAY_SUPPORT?(this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t):X(this,t,e,!0),e+4},$.prototype.writeUInt32BE=function(t,e,r){return t=+t,e|=0,r||Z(this,t,e,4,4294967295,0),$.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):X(this,t,e,!1),e+4},$.prototype.writeIntLE=function(t,e,r,i){if(t=+t,e|=0,!i){var a=Math.pow(2,8*r-1);Z(this,t,e,r,a-1,-a)}var n=0,s=1,o=0;for(this[e]=255&t;++n<r&&(s*=256);)t<0&&0===o&&0!==this[e+n-1]&&(o=1),this[e+n]=(t/s|0)-o&255;return e+r},$.prototype.writeIntBE=function(t,e,r,i){if(t=+t,e|=0,!i){var a=Math.pow(2,8*r-1);Z(this,t,e,r,a-1,-a)}var n=r-1,s=1,o=0;for(this[e+n]=255&t;--n>=0&&(s*=256);)t<0&&0===o&&0!==this[e+n+1]&&(o=1),this[e+n]=(t/s|0)-o&255;return e+r},$.prototype.writeInt8=function(t,e,r){return t=+t,e|=0,r||Z(this,t,e,1,127,-128),$.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[e]=255&t,e+1},$.prototype.writeInt16LE=function(t,e,r){return t=+t,e|=0,r||Z(this,t,e,2,32767,-32768),$.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):J(this,t,e,!0),e+2},$.prototype.writeInt16BE=function(t,e,r){return t=+t,e|=0,r||Z(this,t,e,2,32767,-32768),$.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):J(this,t,e,!1),e+2},$.prototype.writeInt32LE=function(t,e,r){return t=+t,e|=0,r||Z(this,t,e,4,2147483647,-2147483648),$.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24):X(this,t,e,!0),e+4},$.prototype.writeInt32BE=function(t,e,r){return t=+t,e|=0,r||Z(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),$.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):X(this,t,e,!1),e+4},$.prototype.writeFloatLE=function(t,e,r){return tt(this,t,e,!0,r)},$.prototype.writeFloatBE=function(t,e,r){return tt(this,t,e,!1,r)},$.prototype.writeDoubleLE=function(t,e,r){return et(this,t,e,!0,r)},$.prototype.writeDoubleBE=function(t,e,r){return et(this,t,e,!1,r)},$.prototype.copy=function(t,e,r,i){if(r||(r=0),i||0===i||(i=this.length),e>=t.length&&(e=t.length),e||(e=0),i>0&&i<r&&(i=r),i===r)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("sourceStart out of bounds");if(i<0)throw new RangeError("sourceEnd out of bounds");i>this.length&&(i=this.length),t.length-e<i-r&&(i=t.length-e+r);var a,n=i-r;if(this===t&&r<e&&e<i)for(a=n-1;a>=0;--a)t[a+e]=this[a+r];else if(n<1e3||!$.TYPED_ARRAY_SUPPORT)for(a=0;a<n;++a)t[a+e]=this[a+r];else Uint8Array.prototype.set.call(t,this.subarray(r,r+n),e);return n},$.prototype.fill=function(t,e,r,i){if("string"==typeof t){if("string"==typeof e?(i=e,e=0,r=this.length):"string"==typeof r&&(i=r,r=this.length),1===t.length){var a=t.charCodeAt(0);a<256&&(t=a)}if(void 0!==i&&"string"!=typeof i)throw new TypeError("encoding must be a string");if("string"==typeof i&&!$.isEncoding(i))throw new TypeError("Unknown encoding: "+i)}else"number"==typeof t&&(t&=255);if(e<0||this.length<e||this.length<r)throw new RangeError("Out of range index");if(r<=e)return this;var n;if(e>>>=0,r=void 0===r?this.length:r>>>0,t||(t=0),"number"==typeof t)for(n=e;n<r;++n)this[n]=t;else{var s=j(t)?t:at(new $(t,i).toString()),o=s.length;for(n=0;n<r-e;++n)this[n+e]=s[n%o]}return this};var rt=/[^+\/0-9A-Za-z-_]/g;function it(t){return t<16?"0"+t.toString(16):t.toString(16)}function at(t,e){var r;e=e||1/0;for(var i=t.length,a=null,n=[],s=0;s<i;++s){if((r=t.charCodeAt(s))>55295&&r<57344){if(!a){if(r>56319){(e-=3)>-1&&n.push(239,191,189);continue}if(s+1===i){(e-=3)>-1&&n.push(239,191,189);continue}a=r;continue}if(r<56320){(e-=3)>-1&&n.push(239,191,189),a=r;continue}r=65536+(a-55296<<10|r-56320)}else a&&(e-=3)>-1&&n.push(239,191,189);if(a=null,r<128){if((e-=1)<0)break;n.push(r)}else if(r<2048){if((e-=2)<0)break;n.push(r>>6|192,63&r|128)}else if(r<65536){if((e-=3)<0)break;n.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((e-=4)<0)break;n.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return n}function nt(t){return function(t){var e,r,i,a,n,s;l||g();var o=t.length;if(o%4>0)throw new Error("Invalid string. Length must be a multiple of 4");n="="===t[o-2]?2:"="===t[o-1]?1:0,s=new u(3*o/4-n),i=n>0?o-4:o;var c=0;for(e=0,r=0;e<i;e+=4,r+=3)a=h[t.charCodeAt(e)]<<18|h[t.charCodeAt(e+1)]<<12|h[t.charCodeAt(e+2)]<<6|h[t.charCodeAt(e+3)],s[c++]=a>>16&255,s[c++]=a>>8&255,s[c++]=255&a;return 2===n?(a=h[t.charCodeAt(e)]<<2|h[t.charCodeAt(e+1)]>>4,s[c++]=255&a):1===n&&(a=h[t.charCodeAt(e)]<<10|h[t.charCodeAt(e+1)]<<4|h[t.charCodeAt(e+2)]>>2,s[c++]=a>>8&255,s[c++]=255&a),s}(function(t){if((t=function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}(t).replace(rt,"")).length<2)return"";for(;t.length%4!=0;)t+="=";return t}(t))}function st(t,e,r,i){for(var a=0;a<i&&!(a+r>=e.length||a>=t.length);++a)e[a+r]=t[a];return a}function ot(t){return!!t.constructor&&"function"==typeof t.constructor.isBuffer&&t.constructor.isBuffer(t)}function ct(){throw new Error("setTimeout has not been defined")}function ft(){throw new Error("clearTimeout has not been defined")}var dt=ct,ht=ft;function ut(t){if(dt===setTimeout)return setTimeout(t,0);if((dt===ct||!dt)&&setTimeout)return dt=setTimeout,setTimeout(t,0);try{return dt(t,0)}catch(e){try{return dt.call(null,t,0)}catch(e){return dt.call(this,t,0)}}}"function"==typeof f.setTimeout&&(dt=setTimeout),"function"==typeof f.clearTimeout&&(ht=clearTimeout);var lt,gt=[],wt=!1,pt=-1;function mt(){wt&&lt&&(wt=!1,lt.length?gt=lt.concat(gt):pt=-1,gt.length&&yt())}function yt(){if(!wt){var t=ut(mt);wt=!0;for(var e=gt.length;e;){for(lt=gt,gt=[];++pt<e;)lt&&lt[pt].run();pt=-1,e=gt.length}lt=null,wt=!1,function(t){if(ht===clearTimeout)return clearTimeout(t);if((ht===ft||!ht)&&clearTimeout)return ht=clearTimeout,clearTimeout(t);try{return ht(t)}catch(e){try{return ht.call(null,t)}catch(e){return ht.call(this,t)}}}(t)}}function bt(t,e){this.fun=t,this.array=e}bt.prototype.run=function(){this.fun.apply(null,this.array)};function vt(){}var xt=vt,Et=vt,_t=vt,$t=vt,St=vt,At=vt,Pt=vt;var Rt=f.performance||{},kt=Rt.now||Rt.mozNow||Rt.msNow||Rt.oNow||Rt.webkitNow||function(){return(new Date).getTime()};var jt=new Date;var It={nextTick:function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];gt.push(new bt(t,e)),1!==gt.length||wt||ut(yt)},title:"browser",browser:!0,env:{},argv:[],version:"",versions:{},on:xt,addListener:Et,once:_t,off:$t,removeListener:St,removeAllListeners:At,emit:Pt,binding:function(t){throw new Error("process.binding is not supported")},cwd:function(){return"/"},chdir:function(t){throw new Error("process.chdir is not supported")},umask:function(){return 0},hrtime:function(t){var e=.001*kt.call(Rt),r=Math.floor(e),i=Math.floor(e%1*1e9);return t&&(r-=t[0],(i-=t[1])<0&&(r--,i+=1e9)),[r,i]},platform:"browser",release:{},config:{},uptime:function(){return(new Date-jt)/1e3}};class Ot extends Error{constructor(t){super(t),this.caller=""}toJSON(){return{code:this.code,data:this.data,caller:this.caller,message:this.message,stack:this.stack}}fromJSON(t){const e=new Ot(t.message);return e.code=t.code,e.data=t.data,e.caller=t.caller,e.stack=t.stack,e}get isIsomorphicGitError(){return!0}}class Tt extends Ot{constructor(t){super(`Modifying the index is not possible because you have unmerged files: ${t.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`),this.code=this.name=Tt.code,this.data={filepaths:t}}}Tt.code="UnmergedPathsError";class Bt extends Ot{constructor(t){super(`An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${t}`),this.code=this.name=Bt.code,this.data={message:t}}}Bt.code="InternalError";class Ut extends Ot{constructor(t){super(`The filepath "${t}" contains unsafe character sequences`),this.code=this.name=Ut.code,this.data={filepath:t}}}Ut.code="UnsafeFilepathError";class Ct{constructor(t){this.buffer=t,this._start=0}eof(){return this._start>=this.buffer.length}tell(){return this._start}seek(t){this._start=t}slice(t){const e=this.buffer.slice(this._start,this._start+t);return this._start+=t,e}toString(t,e){const r=this.buffer.toString(t,this._start,this._start+e);return this._start+=e,r}write(t,e,r){const i=this.buffer.write(t,this._start,e,r);return this._start+=e,i}copy(t,e,r){const i=t.copy(this.buffer,this._start,e,r);return this._start+=i,i}readUInt8(){const t=this.buffer.readUInt8(this._start);return this._start+=1,t}writeUInt8(t){const e=this.buffer.writeUInt8(t,this._start);return this._start+=1,e}readUInt16BE(){const t=this.buffer.readUInt16BE(this._start);return this._start+=2,t}writeUInt16BE(t){const e=this.buffer.writeUInt16BE(t,this._start);return this._start+=2,e}readUInt32BE(){const t=this.buffer.readUInt32BE(this._start);return this._start+=4,t}writeUInt32BE(t){const e=this.buffer.writeUInt32BE(t,this._start);return this._start+=4,e}}function Dt(t,e){return-(t<e)||+(t>e)}function Mt(t,e){return Dt(t.path,e.path)}function Nt(t){let e=t>0?t>>12:0;4!==e&&8!==e&&10!==e&&14!==e&&(e=8);let r=511&t;return r=73&r?493:420,8!==e&&(r=0),(e<<12)+r}const Ft=2**32;function Ht(t,e,r,i){if(void 0!==t&&void 0!==e)return[t,e];void 0===r&&(r=i.valueOf());const a=Math.floor(r/1e3);return[a,1e6*(r-1e3*a)]}function Lt(t){const[e,r]=Ht(t.ctimeSeconds,t.ctimeNanoseconds,t.ctimeMs,t.ctime),[i,a]=Ht(t.mtimeSeconds,t.mtimeNanoseconds,t.mtimeMs,t.mtime);return{ctimeSeconds:e%Ft,ctimeNanoseconds:r%Ft,mtimeSeconds:i%Ft,mtimeNanoseconds:a%Ft,dev:t.dev%Ft,ino:t.ino%Ft,mode:Nt(t.mode%Ft),uid:t.uid%Ft,gid:t.gid%Ft,size:t.size>-1?t.size%Ft:0}}let zt=null;async function Wt(t){return null===zt&&(zt=await async function(){try{if("da39a3ee5e6b4b0d3255bfef95601890afd80709"===await Yt(new Uint8Array([])))return!0}catch(t){}return!1}()),zt?Yt(t):function(t){return(new e).update(t).digest("hex")}(t)}async function Yt(t){return function(t){let e="";for(const r of new Uint8Array(t))r<16&&(e+="0"),e+=r.toString(16);return e}(await crypto.subtle.digest("SHA-1",t))}class Gt{constructor(t,e){this._dirty=!1,this._unmergedPaths=e||new Set,this._entries=t||new Map}_addEntry(t){if(0===t.flags.stage)t.stages=[t],this._entries.set(t.path,t),this._unmergedPaths.delete(t.path);else{let e=this._entries.get(t.path);e||(this._entries.set(t.path,t),e=t),e.stages[t.flags.stage]=t,this._unmergedPaths.add(t.path)}}static async from(t){if($.isBuffer(t))return Gt.fromBuffer(t);if(null===t)return new Gt(null);throw new Bt("invalid type passed to GitIndex.from")}static async fromBuffer(t){if(0===t.length)throw new Bt("Index file is empty (.git/index)");const e=new Gt,r=new Ct(t),i=r.toString("utf8",4);if("DIRC"!==i)throw new Bt(`Invalid dircache magic file number: ${i}`);const a=await Wt(t.slice(0,-20)),n=t.slice(-20).toString("hex");if(n!==a)throw new Bt(`Invalid checksum in GitIndex buffer: expected ${n} but saw ${a}`);const s=r.readUInt32BE();if(2!==s)throw new Bt(`Unsupported dircache version: ${s}`);const o=r.readUInt32BE();let c=0;for(;!r.eof()&&c<o;){const i={};i.ctimeSeconds=r.readUInt32BE(),i.ctimeNanoseconds=r.readUInt32BE(),i.mtimeSeconds=r.readUInt32BE(),i.mtimeNanoseconds=r.readUInt32BE(),i.dev=r.readUInt32BE(),i.ino=r.readUInt32BE(),i.mode=r.readUInt32BE(),i.uid=r.readUInt32BE(),i.gid=r.readUInt32BE(),i.size=r.readUInt32BE(),i.oid=r.slice(20).toString("hex");const a=r.readUInt16BE();i.flags=(f=a,{assumeValid:Boolean(32768&f),extended:Boolean(16384&f),stage:(12288&f)>>12,nameLength:4095&f});const n=t.indexOf(0,r.tell()+1)-r.tell();if(n<1)throw new Bt(`Got a path length of: ${n}`);if(i.path=r.toString("utf8",n),i.path.includes("..\\")||i.path.includes("../"))throw new Ut(i.path);let s=8-(r.tell()-12)%8;for(0===s&&(s=8);s--;){const t=r.readUInt8();if(0!==t)throw new Bt(`Expected 1-8 null characters but got '${t}' after ${i.path}`);if(r.eof())throw new Bt("Unexpected end of file")}i.stages=[],e._addEntry(i),c++}var f;return e}get unmergedPaths(){return[...this._unmergedPaths]}get entries(){return[...this._entries.values()].sort(Mt)}get entriesMap(){return this._entries}get entriesFlat(){return[...this.entries].flatMap((t=>t.stages.length>1?t.stages.filter((t=>t)):t))}*[Symbol.iterator](){for(const t of this.entries)yield t}insert({filepath:t,stats:e,oid:r,stage:i=0}){e||(e={ctimeSeconds:0,ctimeNanoseconds:0,mtimeSeconds:0,mtimeNanoseconds:0,dev:0,ino:0,mode:0,uid:0,gid:0,size:0}),e=Lt(e);const a=$.from(t),n={ctimeSeconds:e.ctimeSeconds,ctimeNanoseconds:e.ctimeNanoseconds,mtimeSeconds:e.mtimeSeconds,mtimeNanoseconds:e.mtimeNanoseconds,dev:e.dev,ino:e.ino,mode:e.mode||33188,uid:e.uid,gid:e.gid,size:e.size,path:t,oid:r,flags:{assumeValid:!1,extended:!1,stage:i,nameLength:a.length<4095?a.length:4095},stages:[]};this._addEntry(n),this._dirty=!0}delete({filepath:t}){if(this._entries.has(t))this._entries.delete(t);else for(const e of this._entries.keys())e.startsWith(t+"/")&&this._entries.delete(e);this._unmergedPaths.has(t)&&this._unmergedPaths.delete(t),this._dirty=!0}clear(){this._entries.clear(),this._dirty=!0}has({filepath:t}){return this._entries.has(t)}render(){return this.entries.map((t=>`${t.mode.toString(8)} ${t.oid}    ${t.path}`)).join("\n")}static async _entryToBuffer(t){const e=$.from(t.path),r=8*Math.ceil((62+e.length+1)/8),i=$.alloc(r),a=new Ct(i),n=Lt(t);return a.writeUInt32BE(n.ctimeSeconds),a.writeUInt32BE(n.ctimeNanoseconds),a.writeUInt32BE(n.mtimeSeconds),a.writeUInt32BE(n.mtimeNanoseconds),a.writeUInt32BE(n.dev),a.writeUInt32BE(n.ino),a.writeUInt32BE(n.mode),a.writeUInt32BE(n.uid),a.writeUInt32BE(n.gid),a.writeUInt32BE(n.size),a.write(t.oid,20,"hex"),a.writeUInt16BE(function(t){const e=t.flags;return e.extended=!1,e.nameLength=Math.min($.from(t.path).length,4095),(e.assumeValid?32768:0)+(e.extended?16384:0)+((3&e.stage)<<12)+(4095&e.nameLength)}(t)),a.write(t.path,e.length,"utf8"),i}async toObject(){const t=$.alloc(12),e=new Ct(t);e.write("DIRC",4,"utf8"),e.writeUInt32BE(2),e.writeUInt32BE(this.entriesFlat.length);let r=[];for(const t of this.entries)if(r.push(Gt._entryToBuffer(t)),t.stages.length>1)for(const e of t.stages)e&&e!==t&&r.push(Gt._entryToBuffer(e));r=await Promise.all(r);const i=$.concat(r),a=$.concat([t,i]),n=await Wt(a);return $.concat([a,$.from(n,"hex")])}}function qt(t,e,r=!0,i=!0){const a=Lt(t),n=Lt(e);return r&&a.mode!==n.mode||a.mtimeSeconds!==n.mtimeSeconds||a.ctimeSeconds!==n.ctimeSeconds||a.uid!==n.uid||a.gid!==n.gid||i&&a.ino!==n.ino||a.size!==n.size}let Kt=null;const Vt=Symbol("IndexCache");class Zt{static async acquire({fs:e,gitdir:r,cache:i,allowUnmerged:a=!0},n){i[Vt]||(i[Vt]={map:new Map,stats:new Map});const s=`${r}/index`;let o;null===Kt&&(Kt=new t({maxPending:1/0}));let c=[];return await Kt.acquire(s,(async()=>{const t=i[Vt];await async function(t,e,r){const i=r.stats.get(e);if(void 0===i)return!0;if(null===i)return!1;const a=await t.lstat(e);return null!==a&&qt(i,a)}(e,s,t)&&await async function(t,e,r){const[i,a]=await Promise.all([t.lstat(e),t.read(e)]),n=await Gt.from(a);r.map.set(e,n),r.stats.set(e,i)}(e,s,t);const r=t.map.get(s);if(c=r.unmergedPaths,c.length&&!a)throw new Tt(c);if(o=await n(r),r._dirty){const i=await r.toObject();await e.write(s,i),t.stats.set(s,await e.lstat(s)),r._dirty=!1}})),o}}function Jt(t){const e=Math.max(t.lastIndexOf("/"),t.lastIndexOf("\\"));return e>-1&&(t=t.slice(e+1)),t}function Xt(t){const e=Math.max(t.lastIndexOf("/"),t.lastIndexOf("\\"));return-1===e?".":0===e?"/":t.slice(0,e)}function Qt(t){const e=new Map,r=function(t){if(!e.has(t)){const i={type:"tree",fullpath:t,basename:Jt(t),metadata:{},children:[]};e.set(t,i),i.parent=r(Xt(t)),i.parent&&i.parent!==i&&i.parent.children.push(i)}return e.get(t)},i=function(t,i){if(!e.has(t)){const a={type:"blob",fullpath:t,basename:Jt(t),metadata:i,parent:r(Xt(t)),children:[]};a.parent&&a.parent.children.push(a),e.set(t,a)}return e.get(t)};r(".");for(const e of t)i(e.path,e);return e}class te{constructor({fs:t,gitdir:e,cache:r}){this.treePromise=Zt.acquire({fs:t,gitdir:e,cache:r},(async function(t){return Qt(t.entries)}));const i=this;this.ConstructEntry=class{constructor(t){this._fullpath=t,this._type=!1,this._mode=!1,this._stat=!1,this._oid=!1}async type(){return i.type(this)}async mode(){return i.mode(this)}async stat(){return i.stat(this)}async content(){return i.content(this)}async oid(){return i.oid(this)}}}async readdir(t){const e=t._fullpath,r=(await this.treePromise).get(e);if(!r)return null;if("blob"===r.type)return null;if("tree"!==r.type)throw new Error(`ENOTDIR: not a directory, scandir '${e}'`);const i=r.children.map((t=>t.fullpath));return i.sort(Dt),i}async type(t){return!1===t._type&&await t.stat(),t._type}async mode(t){return!1===t._mode&&await t.stat(),t._mode}async stat(t){if(!1===t._stat){const e=(await this.treePromise).get(t._fullpath);if(!e)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);const r="tree"===e.type?{}:Lt(e.metadata);t._type="tree"===e.type?"tree":function(t){switch(t){case 16384:return"tree";case 33188:case 33261:case 40960:return"blob";case 57344:return"commit"}throw new Bt(`Unexpected GitTree entry mode: ${t.toString(8)}`)}(r.mode),t._mode=r.mode,"tree"===e.type?t._stat=void 0:t._stat=r}return t._stat}async content(t){}async oid(t){if(!1===t._oid){const e=(await this.treePromise).get(t._fullpath);t._oid=e.metadata.oid}return t._oid}}const ee=Symbol("GitWalkSymbol");function re(){const t=Object.create(null);return Object.defineProperty(t,ee,{value:function({fs:t,gitdir:e,cache:r}){return new te({fs:t,gitdir:e,cache:r})}}),Object.freeze(t),t}class ie extends Ot{constructor(t){super(`Could not find ${t}.`),this.code=this.name=ie.code,this.data={what:t}}}ie.code="NotFoundError";class ae extends Ot{constructor(t,e,r,i){super(`Object ${t} ${i?`at ${i}`:""}was anticipated to be a ${r} but it is a ${e}.`),this.code=this.name=ae.code,this.data={oid:t,actual:e,expected:r,filepath:i}}}ae.code="ObjectTypeError";class ne extends Ot{constructor(t){super(`Expected a 40-char hex object id but saw "${t}".`),this.code=this.name=ne.code,this.data={value:t}}}ne.code="InvalidOidError";class se extends Ot{constructor(t){super(`Could not find a fetch refspec for remote "${t}". Make sure the config file has an entry like the following:\n[remote "${t}"]\n\tfetch = +refs/heads/*:refs/remotes/origin/*\n`),this.code=this.name=se.code,this.data={remote:t}}}se.code="NoRefspecError";class oe{constructor(t){if(this.refs=new Map,this.parsedConfig=[],t){let e=null;this.parsedConfig=t.trim().split("\n").map((t=>{if(/^\s*#/.test(t))return{line:t,comment:!0};const r=t.indexOf(" ");if(t.startsWith("^")){const r=t.slice(1);return this.refs.set(e+"^{}",r),{line:t,ref:e,peeled:r}}{const i=t.slice(0,r);return e=t.slice(r+1),this.refs.set(e,i),{line:t,ref:e,oid:i}}}))}return this}static from(t){return new oe(t)}delete(t){this.parsedConfig=this.parsedConfig.filter((e=>e.ref!==t)),this.refs.delete(t)}toString(){return this.parsedConfig.map((({line:t})=>t)).join("\n")+"\n"}}class ce{constructor({remotePath:t,localPath:e,force:r,matchPrefix:i}){Object.assign(this,{remotePath:t,localPath:e,force:r,matchPrefix:i})}static from(t){const[e,r,i,a,n]=t.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1),s="+"===e,o="*"===i;if(o!==("*"===n))throw new Bt("Invalid refspec");return new ce({remotePath:r,localPath:a,force:s,matchPrefix:o})}translate(t){if(this.matchPrefix){if(t.startsWith(this.remotePath))return this.localPath+t.replace(this.remotePath,"")}else if(t===this.remotePath)return this.localPath;return null}reverseTranslate(t){if(this.matchPrefix){if(t.startsWith(this.localPath))return this.remotePath+t.replace(this.localPath,"")}else if(t===this.localPath)return this.remotePath;return null}}class fe{constructor(t=[]){this.rules=t}static from(t){const e=[];for(const r of t)e.push(ce.from(r));return new fe(e)}add(t){const e=ce.from(t);this.rules.push(e)}translate(t){const e=[];for(const r of this.rules)for(const i of t){const t=r.translate(i);t&&e.push([i,t])}return e}translateOne(t){let e=null;for(const r of this.rules){const i=r.translate(t);i&&(e=i)}return e}localNamespaces(){return this.rules.filter((t=>t.matchPrefix)).map((t=>t.localPath.replace(/\/$/,"")))}}function de(t,e){const r=t.replace(/\^\{\}$/,""),i=e.replace(/\^\{\}$/,""),a=-(r<i)||+(r>i);return 0===a?t.endsWith("^{}")?1:-1:a}const he=t=>{if("boolean"==typeof t)return t;if("true"===(t=t.trim().toLowerCase())||"yes"===t||"on"===t)return!0;if("false"===t||"no"===t||"off"===t)return!1;throw Error(`Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${t}`)},ue={core:{filemode:he,bare:he,logallrefupdates:he,symlinks:he,ignorecase:he,bigFileThreshold:t=>{if("number"==typeof t)return t;t=t.toLowerCase();let e=parseInt(t);return t.endsWith("k")&&(e*=1024),t.endsWith("m")&&(e*=1048576),t.endsWith("g")&&(e*=1073741824),e}}},le=/^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/,ge=/^[A-Za-z0-9-.]+$/,we=/^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/,pe=/^[A-Za-z][A-Za-z-]*$/,me=/^(.*?)( *[#;].*)$/,ye=t=>{const e=me.exec(t);if(null==e)return t;const[r,i]=e.slice(1);return be(r)&&be(i)?`${r}${i}`:r},be=t=>(t.match(/(?:^|[^\\])"/g)||[]).length%2!=0,ve=t=>t.split("").reduce(((t,e,r,i)=>{const a='"'===e&&"\\"!==i[r-1],n="\\"===e&&'"'===i[r+1];return a||n?t:t+e}),""),xe=t=>null!=t?t.toLowerCase():null,Ee=(t,e,r)=>[xe(t),e,xe(r)].filter((t=>null!=t)).join("."),_e=t=>{const e=t.split("."),r=e.shift(),i=e.pop(),a=e.length?e.join("."):void 0;return{section:r,subsection:a,name:i,path:Ee(r,a,i),sectionPath:Ee(r,a,null),isSection:!!r}};class $e{constructor(t){let e=null,r=null;this.parsedConfig=t?t.split("\n").map((t=>{let i=null,a=null;const n=t.trim(),s=(t=>{const e=le.exec(t);if(null!=e){const[t,r]=e.slice(1);return[t,r]}return null})(n),o=null!=s;if(o)[e,r]=s;else{const t=(t=>{const e=we.exec(t);if(null!=e){const[t,r="true"]=e.slice(1),i=ye(r);return[t,ve(i)]}return null})(n);null!=t&&([i,a]=t)}const c=Ee(e,r,i);return{line:t,isSection:o,section:e,subsection:r,name:i,value:a,path:c}})):[]}static from(t){return new $e(t)}async get(t,e=!1){const r=_e(t).path,i=this.parsedConfig.filter((t=>t.path===r)).map((({section:t,name:e,value:r})=>{const i=ue[t]&&ue[t][e];return i?i(r):r}));return e?i:i.pop()}async getall(t){return this.get(t,!0)}async getSubsections(t){return this.parsedConfig.filter((e=>e.isSection&&e.section===t)).map((t=>t.subsection))}async deleteSection(t,e){this.parsedConfig=this.parsedConfig.filter((r=>!(r.section===t&&r.subsection===e)))}async append(t,e){return this.set(t,e,!0)}async set(t,e,r=!1){const{section:i,subsection:a,name:n,path:s,sectionPath:o,isSection:c}=_e(t),f=(d=this.parsedConfig,h=t=>t.path===s,d.reduce(((t,e,r)=>h(e)?r:t),-1));var d,h;if(null==e)-1!==f&&this.parsedConfig.splice(f,1);else if(-1!==f){const t=this.parsedConfig[f],i=Object.assign({},t,{name:n,value:e,modified:!0});r?this.parsedConfig.splice(f+1,0,i):this.parsedConfig[f]=i}else{const t=this.parsedConfig.findIndex((t=>t.path===o)),r={section:i,subsection:a,name:n,value:e,modified:!0,path:s};if(ge.test(i)&&pe.test(n))if(t>=0)this.parsedConfig.splice(t+1,0,r);else{const t={isSection:c,section:i,subsection:a,modified:!0,path:o};this.parsedConfig.push(t,r)}}}toString(){return this.parsedConfig.map((({line:t,section:e,subsection:r,name:i,value:a,modified:n=!1})=>n?null!=i&&null!=a?"string"==typeof a&&/[#;]/.test(a)?`\t${i} = "${a}"`:`\t${i} = ${a}`:null!=r?`[${e} "${r}"]`:`[${e}]`:t)).join("\n")}}class Se{static async get({fs:t,gitdir:e}){const r=await t.read(`${e}/config`,{encoding:"utf8"});return $e.from(r)}static async save({fs:t,gitdir:e,config:r}){await t.write(`${e}/config`,r.toString(),{encoding:"utf8"})}}const Ae=t=>[`${t}`,`refs/${t}`,`refs/tags/${t}`,`refs/heads/${t}`,`refs/remotes/${t}`,`refs/remotes/${t}/HEAD`],Pe=["config","description","index","shallow","commondir"];let Re;async function ke(e,r){return void 0===Re&&(Re=new t),Re.acquire(e,r)}class je{static async updateRemoteRefs({fs:t,gitdir:e,remote:i,refs:a,symrefs:n,tags:s,refspecs:o,prune:c=!1,pruneTags:f=!1}){for(const t of a.values())if(!t.match(/[0-9a-f]{40}/))throw new ne(t);const d=await Se.get({fs:t,gitdir:e});if(!o){if(0===(o=await d.getall(`remote.${i}.fetch`)).length)throw new se(i);o.unshift(`+HEAD:refs/remotes/${i}/HEAD`)}const h=fe.from(o),u=new Map;if(f){const r=await je.listRefs({fs:t,gitdir:e,filepath:"refs/tags"});await je.deleteRefs({fs:t,gitdir:e,refs:r.map((t=>`refs/tags/${t}`))})}if(s)for(const r of a.keys())if(r.startsWith("refs/tags")&&!r.endsWith("^{}")&&!await je.exists({fs:t,gitdir:e,ref:r})){const t=a.get(r);u.set(r,t)}const l=h.translate([...a.keys()]);for(const[t,e]of l){const r=a.get(t);u.set(e,r)}const g=h.translate([...n.keys()]);for(const[t,e]of g){const r=n.get(t),i=h.translateOne(r);i&&u.set(e,`ref: ${i}`)}const w=[];if(c){for(const r of h.localNamespaces()){const i=(await je.listRefs({fs:t,gitdir:e,filepath:r})).map((t=>`${r}/${t}`));for(const t of i)u.has(t)||w.push(t)}w.length>0&&await je.deleteRefs({fs:t,gitdir:e,refs:w})}for(const[i,a]of u)await ke(i,(async()=>t.write(r(e,i),`${a.trim()}\n`,"utf8")));return{pruned:w}}static async writeRef({fs:t,gitdir:e,ref:i,value:a}){if(!a.match(/[0-9a-f]{40}/))throw new ne(a);await ke(i,(async()=>t.write(r(e,i),`${a.trim()}\n`,"utf8")))}static async writeSymbolicRef({fs:t,gitdir:e,ref:i,value:a}){await ke(i,(async()=>t.write(r(e,i),`ref: ${a.trim()}\n`,"utf8")))}static async deleteRef({fs:t,gitdir:e,ref:r}){return je.deleteRefs({fs:t,gitdir:e,refs:[r]})}static async deleteRefs({fs:t,gitdir:e,refs:i}){await Promise.all(i.map((i=>t.rm(r(e,i)))));let a=await ke("packed-refs",(async()=>t.read(`${e}/packed-refs`,{encoding:"utf8"})));const n=oe.from(a),s=n.refs.size;for(const t of i)n.refs.has(t)&&n.delete(t);n.refs.size<s&&(a=n.toString(),await ke("packed-refs",(async()=>t.write(`${e}/packed-refs`,a,{encoding:"utf8"}))))}static async resolve({fs:t,gitdir:e,ref:r,depth:i}){if(void 0!==i&&-1===--i)return r;if(r.startsWith("ref: "))return r=r.slice(5),je.resolve({fs:t,gitdir:e,ref:r,depth:i});if(40===r.length&&/[0-9a-f]{40}/.test(r))return r;const a=await je.packedRefs({fs:t,gitdir:e}),n=Ae(r).filter((t=>!Pe.includes(t)));for(const r of n){const n=await ke(r,(async()=>await t.read(`${e}/${r}`,{encoding:"utf8"})||a.get(r)));if(n)return je.resolve({fs:t,gitdir:e,ref:n.trim(),depth:i})}throw new ie(r)}static async exists({fs:t,gitdir:e,ref:r}){try{return await je.expand({fs:t,gitdir:e,ref:r}),!0}catch(t){return!1}}static async expand({fs:t,gitdir:e,ref:r}){if(40===r.length&&/[0-9a-f]{40}/.test(r))return r;const i=await je.packedRefs({fs:t,gitdir:e}),a=Ae(r);for(const r of a){if(await ke(r,(async()=>t.exists(`${e}/${r}`))))return r;if(i.has(r))return r}throw new ie(r)}static async expandAgainstMap({ref:t,map:e}){const r=Ae(t);for(const t of r)if(await e.has(t))return t;throw new ie(t)}static resolveAgainstMap({ref:t,fullref:e=t,depth:r,map:i}){if(void 0!==r&&-1===--r)return{fullref:e,oid:t};if(t.startsWith("ref: "))return t=t.slice(5),je.resolveAgainstMap({ref:t,fullref:e,depth:r,map:i});if(40===t.length&&/[0-9a-f]{40}/.test(t))return{fullref:e,oid:t};const a=Ae(t);for(const t of a){const e=i.get(t);if(e)return je.resolveAgainstMap({ref:e.trim(),fullref:t,depth:r,map:i})}throw new ie(t)}static async packedRefs({fs:t,gitdir:e}){const r=await ke("packed-refs",(async()=>t.read(`${e}/packed-refs`,{encoding:"utf8"})));return oe.from(r).refs}static async listRefs({fs:t,gitdir:e,filepath:r}){const i=je.packedRefs({fs:t,gitdir:e});let a=null;try{a=await t.readdirDeep(`${e}/${r}`),a=a.map((t=>t.replace(`${e}/${r}/`,"")))}catch(t){a=[]}for(let t of(await i).keys())t.startsWith(r)&&(t=t.replace(r+"/",""),a.includes(t)||a.push(t));return a.sort(de),a}static async listBranches({fs:t,gitdir:e,remote:r}){return r?je.listRefs({fs:t,gitdir:e,filepath:`refs/remotes/${r}`}):je.listRefs({fs:t,gitdir:e,filepath:"refs/heads"})}static async listTags({fs:t,gitdir:e}){return(await je.listRefs({fs:t,gitdir:e,filepath:"refs/tags"})).filter((t=>!t.endsWith("^{}")))}}function Ie(t,e){return Dt(Oe(t),Oe(e))}function Oe(t){return"040000"===t.mode?t.path+"/":t.path}function Te(t){switch(t){case"040000":return"tree";case"100644":case"100755":case"120000":return"blob";case"160000":return"commit"}throw new Bt(`Unexpected GitTree entry mode: ${t}`)}function Be(t){return!t.oid&&t.sha&&(t.oid=t.sha),t.mode=function(t){if("number"==typeof t&&(t=t.toString(8)),t.match(/^0?4.*/))return"040000";if(t.match(/^1006.*/))return"100644";if(t.match(/^1007.*/))return"100755";if(t.match(/^120.*/))return"120000";if(t.match(/^160.*/))return"160000";throw new Bt(`Could not understand file mode: ${t}`)}(t.mode),t.type||(t.type=Te(t.mode)),t}class Ue{constructor(t){if($.isBuffer(t))this._entries=function(t){const e=[];let r=0;for(;r<t.length;){const i=t.indexOf(32,r);if(-1===i)throw new Bt(`GitTree: Error parsing buffer at byte location ${r}: Could not find the next space character.`);const a=t.indexOf(0,r);if(-1===a)throw new Bt(`GitTree: Error parsing buffer at byte location ${r}: Could not find the next null character.`);let n=t.slice(r,i).toString("utf8");"40000"===n&&(n="040000");const s=Te(n),o=t.slice(i+1,a).toString("utf8");if(o.includes("\\")||o.includes("/"))throw new Ut(o);const c=t.slice(a+1,a+21).toString("hex");r=a+21,e.push({mode:n,path:o,oid:c,type:s})}return e}(t);else{if(!Array.isArray(t))throw new Bt("invalid type passed to GitTree constructor");this._entries=t.map(Be)}this._entries.sort(Mt)}static from(t){return new Ue(t)}render(){return this._entries.map((t=>`${t.mode} ${t.type} ${t.oid}    ${t.path}`)).join("\n")}toObject(){const t=[...this._entries];return t.sort(Ie),$.concat(t.map((t=>{const e=$.from(t.mode.replace(/^0/,"")),r=$.from(" "),i=$.from(t.path,"utf8"),a=$.from([0]),n=$.from(t.oid,"hex");return $.concat([e,r,i,a,n])})))}entries(){return this._entries}*[Symbol.iterator](){for(const t of this._entries)yield t}}class Ce{static wrap({type:t,object:e}){return $.concat([$.from(`${t} ${e.byteLength.toString()}\0`),$.from(e)])}static unwrap(t){const e=t.indexOf(32),r=t.indexOf(0),i=t.slice(0,e).toString("utf8"),a=t.slice(e+1,r).toString("utf8"),n=t.length-(r+1);if(parseInt(a)!==n)throw new Bt(`Length mismatch: expected ${a} bytes but got ${n} instead.`);return{type:i,object:$.from(t.slice(r+1))}}}async function De({fs:t,gitdir:e,oid:r}){const i=`objects/${r.slice(0,2)}/${r.slice(2)}`,a=await t.read(`${e}/${i}`);return a?{object:a,format:"deflated",source:i}:null}function Me(t){let e=0,r=0,i=null;do{i=t.readUInt8(),e|=(127&i)<<r,r+=7}while(128&i);return e}function Ne(t,e,r){let i=0,a=0;for(;r--;)1&e&&(i|=t.readUInt8()<<a),e>>=1,a+=8;return i}function Fe(t,e){const r=t.readUInt8();if(128&r){const i=Ne(t,15&r,4);let a=Ne(t,(112&r)>>4,3);return 0===a&&(a=65536),e.slice(i,i+a)}return t.slice(r)}function He(t){return t[Symbol.asyncIterator]?t[Symbol.asyncIterator]():t[Symbol.iterator]?t[Symbol.iterator]():t.next?t:function(t){let e=[t];return{next:()=>Promise.resolve({done:0===e.length,value:e.pop()}),return:()=>(e=[],{}),[Symbol.asyncIterator](){return this}}}(t)}class Le{constructor(t){if(void 0===$)throw new Error("Missing Buffer dependency");this.stream=He(t),this.buffer=null,this.cursor=0,this.undoCursor=0,this.started=!1,this._ended=!1,this._discardedBytes=0}eof(){return this._ended&&this.cursor===this.buffer.length}tell(){return this._discardedBytes+this.cursor}async byte(){if(!this.eof()&&(this.started||await this._init(),this.cursor!==this.buffer.length||(await this._loadnext(),!this._ended)))return this._moveCursor(1),this.buffer[this.undoCursor]}async chunk(){if(!this.eof()&&(this.started||await this._init(),this.cursor!==this.buffer.length||(await this._loadnext(),!this._ended)))return this._moveCursor(this.buffer.length),this.buffer.slice(this.undoCursor,this.cursor)}async read(t){if(!this.eof())return this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t),this.buffer.slice(this.undoCursor,this.cursor)}async skip(t){this.eof()||(this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t))}async undo(){this.cursor=this.undoCursor}async _next(){this.started=!0;let{done:t,value:e}=await this.stream.next();return t&&(this._ended=!0,!e)?$.alloc(0):(e&&(e=$.from(e)),e)}_trim(){this.buffer=this.buffer.slice(this.undoCursor),this.cursor-=this.undoCursor,this._discardedBytes+=this.undoCursor,this.undoCursor=0}_moveCursor(t){this.undoCursor=this.cursor,this.cursor+=t,this.cursor>this.buffer.length&&(this.cursor=this.buffer.length)}async _accumulate(t){if(this._ended)return;const e=[this.buffer];for(;this.cursor+t>ze(e);){const t=await this._next();if(this._ended)break;e.push(t)}this.buffer=$.concat(e)}async _loadnext(){this._discardedBytes+=this.buffer.length,this.undoCursor=0,this.cursor=0,this.buffer=await this._next()}async _init(){this.buffer=await this._next()}}function ze(t){return t.reduce(((t,e)=>t+e.length),0)}async function We(t){let e=await t.byte();const r=e>>4&7;let i,a,n=15&e;if(128&e){let r=4;do{e=await t.byte(),n|=(127&e)<<r,r+=7}while(128&e)}if(6===r){let r=0;i=0;const n=[];do{e=await t.byte(),i|=(127&e)<<r,r+=7,n.push(e)}while(128&e);a=$.from(n)}if(7===r){a=await t.read(20)}return{type:r,length:n,ofs:i,reference:a}}async function Ye(t){return a.inflate(t)}class Ge{constructor(t){Object.assign(this,t),this.offsetCache={}}static async fromIdx({idx:t,getExternalRefDelta:e}){const r=new Ct(t);if("ff744f63"!==r.slice(4).toString("hex"))return;const i=r.readUInt32BE();if(2!==i)throw new Bt(`Unable to read version ${i} packfile IDX. (Only version 2 supported)`);if(t.byteLength>2147483648)throw new Bt("To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.");r.seek(r.tell()+1020);const a=r.readUInt32BE(),n=[];for(let t=0;t<a;t++){const e=r.slice(20).toString("hex");n[t]=e}r.seek(r.tell()+4*a);const s=new Map;for(let t=0;t<a;t++)s.set(n[t],r.readUInt32BE());const o=r.slice(20).toString("hex");return new Ge({hashes:n,crcs:{},offsets:s,packfileSha:o,getExternalRefDelta:e})}static async fromPack({pack:t,getExternalRefDelta:e,onProgress:r}){const n={1:"commit",2:"tree",3:"blob",4:"tag",6:"ofs-delta",7:"ref-delta"},s={},o=t.slice(-20).toString("hex"),c=[],f={},d=new Map;let h=null,u=null;await async function(t,e){const r=new Le(t);let i=await r.read(4);if(i=i.toString("utf8"),"PACK"!==i)throw new Bt(`Invalid PACK header '${i}'`);let n=await r.read(4);if(n=n.readUInt32BE(0),2!==n)throw new Bt(`Invalid packfile version: ${n}`);let s=await r.read(4);if(s=s.readUInt32BE(0),!(s<1))for(;!r.eof()&&s--;){const t=r.tell(),{type:i,length:n,ofs:o,reference:c}=await We(r),f=new a.Inflate;for(;!f.result;){const a=await r.chunk();if(!a)break;if(f.push(a,!1),f.err)throw new Bt(`Pako error: ${f.msg}`);if(f.result){if(f.result.length!==n)throw new Bt("Inflated object size is different from that stated in packfile.");await r.undo(),await r.read(a.length-f.strm.avail_in);const d=r.tell();await e({data:f.result,type:i,num:s,offset:t,end:d,reference:c,ofs:o})}}}}([t],(async({data:t,type:e,reference:i,offset:a,num:o})=>{null===h&&(h=o);const c=Math.floor(100*(h-o)/h);c!==u&&r&&await r({phase:"Receiving objects",loaded:h-o,total:h}),u=c,(["commit","tree","blob","tag"].includes(e=n[e])||"ofs-delta"===e||"ref-delta"===e)&&(s[a]={type:e,offset:a})}));const l=Object.keys(s).map(Number);for(const[e,r]of l.entries()){const a=e+1===l.length?t.byteLength-20:l[e+1],n=s[r],o=i.buf(t.slice(r,a))>>>0;n.end=a,n.crc=o}const g=new Ge({pack:Promise.resolve(t),packfileSha:o,crcs:f,hashes:c,offsets:d,getExternalRefDelta:e});u=null;let w=0;const p=[0,0,0,0,0,0,0,0,0,0,0,0];for(let t in s){t=Number(t);const e=Math.floor(100*w/h);e!==u&&r&&await r({phase:"Resolving deltas",loaded:w,total:h}),w++,u=e;const i=s[t];if(!i.oid)try{g.readDepth=0,g.externalReadDepth=0;const{type:e,object:r}=await g.readSlice({start:t});p[g.readDepth]+=1;const a=await Wt(Ce.wrap({type:e,object:r}));i.oid=a,c.push(a),d.set(a,t),f[a]=i.crc}catch(t){continue}}return c.sort(),g}async toBuffer(){const t=[],e=(e,r)=>{t.push($.from(e,r))};e("ff744f63","hex"),e("00000002","hex");const r=new Ct($.alloc(1024));for(let t=0;t<256;t++){let e=0;for(const r of this.hashes)parseInt(r.slice(0,2),16)<=t&&e++;r.writeUInt32BE(e)}t.push(r.buffer);for(const t of this.hashes)e(t,"hex");const i=new Ct($.alloc(4*this.hashes.length));for(const t of this.hashes)i.writeUInt32BE(this.crcs[t]);t.push(i.buffer);const a=new Ct($.alloc(4*this.hashes.length));for(const t of this.hashes)a.writeUInt32BE(this.offsets.get(t));t.push(a.buffer),e(this.packfileSha,"hex");const n=$.concat(t),s=await Wt(n),o=$.alloc(20);return o.write(s,"hex"),$.concat([n,o])}async load({pack:t}){this.pack=t}async unload(){this.pack=null}async read({oid:t}){if(!this.offsets.get(t)){if(this.getExternalRefDelta)return this.externalReadDepth++,this.getExternalRefDelta(t);throw new Bt(`Could not read object ${t} from packfile`)}const e=this.offsets.get(t);return this.readSlice({start:e})}async readSlice({start:t}){if(this.offsetCache[t])return Object.assign({},this.offsetCache[t]);this.readDepth++;if(!this.pack)throw new Bt("Tried to read from a GitPackIndex with no packfile loaded into memory");const e=(await this.pack).slice(t),r=new Ct(e),i=r.readUInt8(),a=112&i;let n={16:"commit",32:"tree",48:"blob",64:"tag",96:"ofs_delta",112:"ref_delta"}[a];if(void 0===n)throw new Bt("Unrecognized type: 0b"+a.toString(2));const s=15&i;let o=s;128&i&&(o=function(t,e){let r=e,i=4,a=null;do{a=t.readUInt8(),r|=(127&a)<<i,i+=7}while(128&a);return r}(r,s));let c=null,f=null;if("ofs_delta"===n){const e=function(t){const e=[];let r=0,i=0;do{r=t.readUInt8();const a=127&r;e.push(a),i=128&r}while(i);return e.reduce(((t,e)=>t+1<<7|e),-1)}(r),i=t-e;({object:c,type:n}=await this.readSlice({start:i}))}if("ref_delta"===n){const t=r.slice(20).toString("hex");({object:c,type:n}=await this.read({oid:t}))}const d=e.slice(r.tell());if(f=$.from(await Ye(d)),f.byteLength!==o)throw new Bt(`Packfile told us object would have length ${o} but it had length ${f.byteLength}`);return c&&(f=$.from(function(t,e){const r=new Ct(t),i=Me(r);if(i!==e.byteLength)throw new Bt(`applyDelta expected source buffer to be ${i} bytes but the provided buffer was ${e.length} bytes`);const a=Me(r);let n;const s=Fe(r,e);if(s.byteLength===a)n=s;else{n=$.alloc(a);const t=new Ct(n);for(t.copy(s);!r.eof();)t.copy(Fe(r,e));const i=t.tell();if(a!==i)throw new Bt(`applyDelta expected target buffer to be ${a} bytes but the resulting buffer was ${i} bytes`)}return n}(f,c))),this.readDepth>3&&(this.offsetCache[t]={type:n,object:f}),{type:n,format:"content",object:f}}}const qe=Symbol("PackfileCache");function Ke({fs:t,cache:e,filename:r,getExternalRefDelta:i,emitter:a,emitterPrefix:n}){e[qe]||(e[qe]=new Map);let s=e[qe].get(r);return s||(s=async function({fs:t,filename:e,getExternalRefDelta:r,emitter:i,emitterPrefix:a}){const n=await t.read(e);return Ge.fromIdx({idx:n,getExternalRefDelta:r})}({fs:t,filename:r,getExternalRefDelta:i,emitter:a,emitterPrefix:n}),e[qe].set(r,s)),s}async function Ve({fs:t,cache:e,gitdir:i,oid:a,format:n="content"}){const s=r=>Ve({fs:t,cache:e,gitdir:i,oid:r});let o;if("4b825dc642cb6eb9a060e54bf8d69288fbee4904"===a&&(o={format:"wrapped",object:$.from("tree 0\0")}),o||(o=await De({fs:t,gitdir:i,oid:a})),!o){if(o=await async function({fs:t,cache:e,gitdir:i,oid:a,format:n="content",getExternalRefDelta:s}){let o=await t.readdir(r(i,"objects/pack"));o=o.filter((t=>t.endsWith(".idx")));for(const r of o){const n=`${i}/objects/pack/${r}`,o=await Ke({fs:t,cache:e,filename:n,getExternalRefDelta:s});if(o.error)throw new Bt(o.error);if(o.offsets.has(a)){if(!o.pack){const e=n.replace(/idx$/,"pack");o.pack=t.read(e)}const e=await o.read({oid:a,getExternalRefDelta:s});return e.format="content",e.source=`objects/pack/${r.replace(/idx$/,"pack")}`,e}}return null}({fs:t,cache:e,gitdir:i,oid:a,getExternalRefDelta:s}),!o)throw new ie(a);return o}if("deflated"===n)return o;if("deflated"===o.format&&(o.object=$.from(await Ye(o.object)),o.format="wrapped"),"wrapped"===n)return o;const c=await Wt(o.object);if(c!==a)throw new Bt(`SHA check failed! Expected ${a}, computed ${c}`);const{object:f,type:d}=Ce.unwrap(o.object);if(o.type=d,o.object=f,o.format="content","content"===n)return o;throw new Bt(`invalid requested format "${n}"`)}class Ze extends Ot{constructor(t,e,r=!0){super(`Failed to create ${t} at ${e} because it already exists.${r?` (Hint: use 'force: true' parameter to overwrite existing ${t}.)`:""}`),this.code=this.name=Ze.code,this.data={noun:t,where:e,canForce:r}}}Ze.code="AlreadyExistsError";class Je extends Ot{constructor(t,e,r){super(`Found multiple ${t} matching "${e}" (${r.join(", ")}). Use a longer abbreviation length to disambiguate them.`),this.code=this.name=Je.code,this.data={nouns:t,short:e,matches:r}}}Je.code="AmbiguousError";class Xe extends Ot{constructor(t){super(`Your local changes to the following files would be overwritten by checkout: ${t.join(", ")}`),this.code=this.name=Xe.code,this.data={filepaths:t}}}Xe.code="CheckoutConflictError";class Qe extends Ot{constructor(t,e){super(`Failed to checkout "${t}" because commit ${e} is not available locally. Do a git fetch to make the branch available locally.`),this.code=this.name=Qe.code,this.data={ref:t,oid:e}}}Qe.code="CommitNotFetchedError";class tr extends Ot{constructor(){super("Empty response from git server."),this.code=this.name=tr.code,this.data={}}}tr.code="EmptyServerResponseError";class er extends Ot{constructor(){super("A simple fast-forward merge was not possible."),this.code=this.name=er.code,this.data={}}}er.code="FastForwardError";class rr extends Ot{constructor(t,e){super(`One or more branches were not updated: ${t}`),this.code=this.name=rr.code,this.data={prettyDetails:t,result:e}}}rr.code="GitPushError";class ir extends Ot{constructor(t,e,r){super(`HTTP Error: ${t} ${e}`),this.code=this.name=ir.code,this.data={statusCode:t,statusMessage:e,response:r}}}ir.code="HttpError";class ar extends Ot{constructor(t){let e="invalid filepath";"leading-slash"===t||"trailing-slash"===t?e='"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.':"directory"===t&&(e='"filepath" should not be a directory.'),super(e),this.code=this.name=ar.code,this.data={reason:t}}}ar.code="InvalidFilepathError";class nr extends Ot{constructor(t,e){super(`"${t}" would be an invalid git reference. (Hint: a valid alternative would be "${e}".)`),this.code=this.name=nr.code,this.data={ref:t,suggestion:e}}}nr.code="InvalidRefNameError";class sr extends Ot{constructor(t){super(`Maximum search depth of ${t} exceeded.`),this.code=this.name=sr.code,this.data={depth:t}}}sr.code="MaxDepthError";class or extends Ot{constructor(){super("Merges with conflicts are not supported yet."),this.code=this.name=or.code,this.data={}}}or.code="MergeNotSupportedError";class cr extends Ot{constructor(t,e,r,i){super(`Automatic merge failed with one or more merge conflicts in the following files: ${t.toString()}. Fix conflicts then commit the result.`),this.code=this.name=cr.code,this.data={filepaths:t,bothModified:e,deleteByUs:r,deleteByTheirs:i}}}cr.code="MergeConflictError";class fr extends Ot{constructor(t){super(`No name was provided for ${t} in the argument or in the .git/config file.`),this.code=this.name=fr.code,this.data={role:t}}}fr.code="MissingNameError";class dr extends Ot{constructor(t){super(`The function requires a "${t}" parameter but none was provided.`),this.code=this.name=dr.code,this.data={parameter:t}}}dr.code="MissingParameterError";class hr extends Ot{constructor(t){super('There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more'),this.code=this.name=hr.code,this.data={errors:t},this.errors=t}}hr.code="MultipleGitError";class ur extends Ot{constructor(t,e){super(`Expected "${t}" but received "${e}".`),this.code=this.name=ur.code,this.data={expected:t,actual:e}}}ur.code="ParseError";class lr extends Ot{constructor(t){let e="";"not-fast-forward"===t?e=" because it was not a simple fast-forward":"tag-exists"===t&&(e=" because tag already exists"),super(`Push rejected${e}. Use "force: true" to override.`),this.code=this.name=lr.code,this.data={reason:t}}}lr.code="PushRejectedError";class gr extends Ot{constructor(t,e){super(`Remote does not support the "${t}" so the "${e}" parameter cannot be used.`),this.code=this.name=gr.code,this.data={capability:t,parameter:e}}}gr.code="RemoteCapabilityError";class wr extends Ot{constructor(t,e){super(`Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${t}`),this.code=this.name=wr.code,this.data={preview:t,response:e}}}wr.code="SmartHttpError";class pr extends Ot{constructor(t,e,r){super(`Git remote "${t}" uses an unrecognized transport protocol: "${e}"`),this.code=this.name=pr.code,this.data={url:t,transport:e,suggestion:r}}}pr.code="UnknownTransportError";class mr extends Ot{constructor(t){super(`Cannot parse remote URL: "${t}"`),this.code=this.name=mr.code,this.data={url:t}}}mr.code="UrlParseError";class yr extends Ot{constructor(){super("The operation was canceled."),this.code=this.name=yr.code,this.data={}}}yr.code="UserCanceledError";class br extends Ot{constructor(t){super(`Could not merge index: Entry for '${t}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged changes.`),this.code=this.name=br.code,this.data={filepath:t}}}br.code="IndexResetError";class vr extends Ot{constructor(t){super(`"${t}" does not point to any commit. You're maybe working on a repository with no commits yet. `),this.code=this.name=vr.code,this.data={ref:t}}}vr.code="NoCommitError";var xr=Object.freeze({__proto__:null,AlreadyExistsError:Ze,AmbiguousError:Je,CheckoutConflictError:Xe,CommitNotFetchedError:Qe,EmptyServerResponseError:tr,FastForwardError:er,GitPushError:rr,HttpError:ir,InternalError:Bt,InvalidFilepathError:ar,InvalidOidError:ne,InvalidRefNameError:nr,MaxDepthError:sr,MergeNotSupportedError:or,MergeConflictError:cr,MissingNameError:fr,MissingParameterError:dr,MultipleGitError:hr,NoRefspecError:se,NotFoundError:ie,ObjectTypeError:ae,ParseError:ur,PushRejectedError:lr,RemoteCapabilityError:gr,SmartHttpError:wr,UnknownTransportError:pr,UnsafeFilepathError:Ut,UrlParseError:mr,UserCanceledError:yr,UnmergedPathsError:Tt,IndexResetError:br,NoCommitError:vr});function Er({name:t,email:e,timestamp:r,timezoneOffset:i}){return`${t} <${e}> ${r} ${i=function(t){const e=function(t){return Math.sign(t)||(Object.is(t,-0)?-1:1)}((r=t,0===r?r:-r));var r;t=Math.abs(t);const i=Math.floor(t/60);t-=60*i;let a=String(i),n=String(t);a.length<2&&(a="0"+a);n.length<2&&(n="0"+n);return(-1===e?"-":"+")+a+n}(i)}`}function _r(t){return t=(t=(t=t.replace(/\r/g,"")).replace(/^\n+/,"")).replace(/\n+$/,"")+"\n"}function $r(t){const[,e,r,i,a]=t.match(/^(.*) <(.*)> (.*) (.*)$/);return{name:e,email:r,timestamp:Number(i),timezoneOffset:Sr(a)}}function Sr(t){let[,e,r,i]=t.match(/(\+|-)(\d\d)(\d\d)/);return i=("+"===e?1:-1)*(60*Number(r)+Number(i)),0===(a=i)?a:-a;var a}class Ar{constructor(t){if("string"==typeof t)this._tag=t;else if($.isBuffer(t))this._tag=t.toString("utf8");else{if("object"!=typeof t)throw new Bt("invalid type passed to GitAnnotatedTag constructor");this._tag=Ar.render(t)}}static from(t){return new Ar(t)}static render(t){return`object ${t.object}\ntype ${t.type}\ntag ${t.tag}\ntagger ${Er(t.tagger)}\n\n${t.message}\n${t.gpgsig?t.gpgsig:""}`}justHeaders(){return this._tag.slice(0,this._tag.indexOf("\n\n"))}message(){const t=this.withoutSignature();return t.slice(t.indexOf("\n\n")+2)}parse(){return Object.assign(this.headers(),{message:this.message(),gpgsig:this.gpgsig()})}render(){return this._tag}headers(){const t=this.justHeaders().split("\n"),e=[];for(const r of t)" "===r[0]?e[e.length-1]+="\n"+r.slice(1):e.push(r);const r={};for(const t of e){const e=t.slice(0,t.indexOf(" ")),i=t.slice(t.indexOf(" ")+1);Array.isArray(r[e])?r[e].push(i):r[e]=i}return r.tagger&&(r.tagger=$r(r.tagger)),r.committer&&(r.committer=$r(r.committer)),r}withoutSignature(){const t=_r(this._tag);return-1===t.indexOf("\n-----BEGIN PGP SIGNATURE-----")?t:t.slice(0,t.lastIndexOf("\n-----BEGIN PGP SIGNATURE-----"))}gpgsig(){if(-1===this._tag.indexOf("\n-----BEGIN PGP SIGNATURE-----"))return;return _r(this._tag.slice(this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),this._tag.indexOf("-----END PGP SIGNATURE-----")+27))}payload(){return this.withoutSignature()+"\n"}toObject(){return $.from(this._tag,"utf8")}static async sign(t,e,r){const i=t.payload();let{signature:a}=await e({payload:i,secretKey:r});a=_r(a);const n=i+a;return Ar.from(n)}}function Pr(t){return t.trim().split("\n").map((t=>" "+t)).join("\n")+"\n"}class Rr{constructor(t){if("string"==typeof t)this._commit=t;else if($.isBuffer(t))this._commit=t.toString("utf8");else{if("object"!=typeof t)throw new Bt("invalid type passed to GitCommit constructor");this._commit=Rr.render(t)}}static fromPayloadSignature({payload:t,signature:e}){const r=Rr.justHeaders(t),i=Rr.justMessage(t),a=_r(r+"\ngpgsig"+Pr(e)+"\n"+i);return new Rr(a)}static from(t){return new Rr(t)}toObject(){return $.from(this._commit,"utf8")}headers(){return this.parseHeaders()}message(){return Rr.justMessage(this._commit)}parse(){return Object.assign({message:this.message()},this.headers())}static justMessage(t){return _r(t.slice(t.indexOf("\n\n")+2))}static justHeaders(t){return t.slice(0,t.indexOf("\n\n"))}parseHeaders(){const t=Rr.justHeaders(this._commit).split("\n"),e=[];for(const r of t)" "===r[0]?e[e.length-1]+="\n"+r.slice(1):e.push(r);const r={parent:[]};for(const t of e){const e=t.slice(0,t.indexOf(" ")),i=t.slice(t.indexOf(" ")+1);Array.isArray(r[e])?r[e].push(i):r[e]=i}return r.author&&(r.author=$r(r.author)),r.committer&&(r.committer=$r(r.committer)),r}static renderHeaders(t){let e="";if(t.tree?e+=`tree ${t.tree}\n`:e+="tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\n",t.parent){if(void 0===t.parent.length)throw new Bt("commit 'parent' property should be an array");for(const r of t.parent)e+=`parent ${r}\n`}e+=`author ${Er(t.author)}\n`;return e+=`committer ${Er(t.committer||t.author)}\n`,t.gpgsig&&(e+="gpgsig"+Pr(t.gpgsig)),e}static render(t){return Rr.renderHeaders(t)+"\n"+_r(t.message)}render(){return this._commit}withoutSignature(){const t=_r(this._commit);if(-1===t.indexOf("\ngpgsig"))return t;return _r(t.slice(0,t.indexOf("\ngpgsig"))+"\n"+t.slice(t.indexOf("-----END PGP SIGNATURE-----\n")+28))}isolateSignature(){const t=this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),this._commit.indexOf("-----END PGP SIGNATURE-----")+27);return t.split("\n").map((t=>t.replace(/^ /,""))).join("\n")}static async sign(t,e,r){const i=t.withoutSignature(),a=Rr.justMessage(t._commit);let{signature:n}=await e({payload:i,secretKey:r});n=_r(n);const s=Rr.justHeaders(t._commit)+"\ngpgsig"+Pr(n)+"\n"+a;return Rr.from(s)}}async function kr({fs:t,cache:e,gitdir:r,oid:i}){if("4b825dc642cb6eb9a060e54bf8d69288fbee4904"===i)return{tree:Ue.from([]),oid:i};const{type:a,object:n}=await Ve({fs:t,cache:e,gitdir:r,oid:i});if("tag"===a)return kr({fs:t,cache:e,gitdir:r,oid:i=Ar.from(n).parse().object});if("commit"===a)return kr({fs:t,cache:e,gitdir:r,oid:i=Rr.from(n).parse().tree});if("tree"!==a)throw new ae(i,a,"tree");return{tree:Ue.from(n),oid:i}}class jr{constructor({fs:t,gitdir:e,ref:r,cache:i}){this.fs=t,this.cache=i,this.gitdir=e,this.mapPromise=(async()=>{const i=new Map;let a;try{a=await je.resolve({fs:t,gitdir:e,ref:r})}catch(t){t instanceof ie&&(a="4b825dc642cb6eb9a060e54bf8d69288fbee4904")}const n=await kr({fs:t,cache:this.cache,gitdir:e,oid:a});return n.type="tree",n.mode="40000",i.set(".",n),i})();const a=this;this.ConstructEntry=class{constructor(t){this._fullpath=t,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return a.type(this)}async mode(){return a.mode(this)}async stat(){return a.stat(this)}async content(){return a.content(this)}async oid(){return a.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:i,cache:a,gitdir:n}=this,s=await this.mapPromise,o=s.get(e);if(!o)throw new Error(`No obj for ${e}`);const c=o.oid;if(!c)throw new Error(`No oid for obj ${JSON.stringify(o)}`);if("tree"!==o.type)return null;const{type:f,object:d}=await Ve({fs:i,cache:a,gitdir:n,oid:c});if(f!==o.type)throw new ae(c,f,o.type);const h=Ue.from(d);for(const t of h)s.set(r(e,t.path),t);return h.entries().map((t=>r(e,t.path)))}async type(t){if(!1===t._type){const e=await this.mapPromise,{type:r}=e.get(t._fullpath);t._type=r}return t._type}async mode(t){if(!1===t._mode){const e=await this.mapPromise,{mode:r}=e.get(t._fullpath);t._mode=Nt(parseInt(r,8))}return t._mode}async stat(t){}async content(t){if(!1===t._content){const e=await this.mapPromise,{fs:r,cache:i,gitdir:a}=this,n=e.get(t._fullpath).oid,{type:s,object:o}=await Ve({fs:r,cache:i,gitdir:a,oid:n});t._content="blob"!==s?void 0:new Uint8Array(o)}return t._content}async oid(t){if(!1===t._oid){const e=(await this.mapPromise).get(t._fullpath);t._oid=e.oid}return t._oid}}function Ir({ref:t="HEAD"}={}){const e=Object.create(null);return Object.defineProperty(e,ee,{value:function({fs:e,gitdir:r,cache:i}){return new jr({fs:e,gitdir:r,ref:t,cache:i})}}),Object.freeze(e),e}class Or{constructor({fs:t,dir:e,gitdir:r,cache:i}){this.fs=t,this.cache=i,this.dir=e,this.gitdir=r,this.config=null;const a=this;this.ConstructEntry=class{constructor(t){this._fullpath=t,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return a.type(this)}async mode(){return a.mode(this)}async stat(){return a.stat(this)}async content(){return a.content(this)}async oid(){return a.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:i,dir:a}=this,n=await i.readdir(r(a,e));return null===n?null:n.map((t=>r(e,t)))}async type(t){return!1===t._type&&await t.stat(),t._type}async mode(t){return!1===t._mode&&await t.stat(),t._mode}async stat(t){if(!1===t._stat){const{fs:e,dir:r}=this;let i=await e.lstat(`${r}/${t._fullpath}`);if(!i)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);let a=i.isDirectory()?"tree":"blob";"blob"!==a||i.isFile()||i.isSymbolicLink()||(a="special"),t._type=a,i=Lt(i),t._mode=i.mode,-1===i.size&&t._actualSize&&(i.size=t._actualSize),t._stat=i}return t._stat}async content(t){if(!1===t._content){const{fs:e,dir:r,gitdir:i}=this;if("tree"===await t.type())t._content=void 0;else{const a=await this._getGitConfig(e,i),n=await a.get("core.autocrlf"),s=await e.read(`${r}/${t._fullpath}`,{autocrlf:n});t._actualSize=s.length,t._stat&&-1===t._stat.size&&(t._stat.size=t._actualSize),t._content=new Uint8Array(s)}}return t._content}async oid(t){if(!1===t._oid){const e=this,{fs:r,gitdir:i,cache:a}=this;let n;await Zt.acquire({fs:r,gitdir:i,cache:a},(async function(a){const s=a.entriesMap.get(t._fullpath),o=await t.stat(),c=await e._getGitConfig(r,i),f=await c.get("core.filemode"),d=!("win32"===It.platform);if(!s||qt(o,s,f,d)){const e=await t.content();void 0===e?n=void 0:(n=await Wt(Ce.wrap({type:"blob",object:e})),!s||n!==s.oid||f&&o.mode!==s.mode||!qt(o,s,f,d)||a.insert({filepath:t._fullpath,stats:o,oid:n}))}else n=s.oid})),t._oid=n}return t._oid}async _getGitConfig(t,e){return this.config||(this.config=await Se.get({fs:t,gitdir:e})),this.config}}function Tr(){const t=Object.create(null);return Object.defineProperty(t,ee,{value:function({fs:t,dir:e,gitdir:r,cache:i}){return new Or({fs:t,dir:e,gitdir:r,cache:i})}}),Object.freeze(t),t}const Br=void 0===Array.prototype.flat?t=>t.reduce(((t,e)=>t.concat(e)),[]):t=>t.flat();class Ur{constructor(){this.value=null}consider(t){null!=t&&(null===this.value||t<this.value)&&(this.value=t)}reset(){this.value=null}}function*Cr(t){const e=new Ur;let r;const i=[],a=t.length;for(let r=0;r<a;r++)i[r]=t[r].next().value,void 0!==i[r]&&e.consider(i[r]);if(null!==e.value)for(;;){const n=[];r=e.value,e.reset();for(let s=0;s<a;s++)void 0!==i[s]&&i[s]===r?(n[s]=i[s],i[s]=t[s].next().value):n[s]=null,void 0!==i[s]&&e.consider(i[s]);if(yield n,null===e.value)return}}async function Dr({fs:t,cache:e,dir:r,gitdir:i,trees:a,map:n=async(t,e)=>e,reduce:s=async(t,e)=>{const r=Br(e);return void 0!==t&&r.unshift(t),r},iterate:o=(t,e)=>Promise.all([...e].map(t))}){const c=a.map((a=>a[ee]({fs:t,dir:r,gitdir:i,cache:e}))),f=new Array(c.length).fill("."),d=function(t,e){const r=e-t;return Array.from({length:r},((e,r)=>t+r))}(0,c.length),h=async t=>{const{entries:e,children:r}=await(async t=>{d.map((e=>{const r=t[e];t[e]=r&&new c[e].ConstructEntry(r)}));const e=(await Promise.all(d.map((e=>{const r=t[e];return r?c[e].readdir(r):[]})))).map((t=>(null===t?[]:t)[Symbol.iterator]()));return{entries:t,children:Cr(e)}})(t),i=e.find((t=>t&&t._fullpath))._fullpath,a=await n(i,e);if(null!==a){let t=await o(h,r);return t=t.filter((t=>void 0!==t)),s(a,t)}};return h(f)}async function Mr(t,e){const i=await t.readdir(e);null==i?await t.rm(e):i.length?await Promise.all(i.map((i=>{const a=r(e,i);return t.lstat(a).then((e=>{if(e)return e.isDirectory()?Mr(t,a):t.rm(a)}))}))).then((()=>t.rmdir(e))):await t.rmdir(e)}function Nr(t){return"function"==typeof t}function Fr(t){return function(t){return t&&"object"==typeof t}(e=(t=>{try{return t.readFile().catch((t=>t))}catch(t){return t}})(t))&&Nr(e.then)&&Nr(e.catch);var e}const Hr=["readFile","writeFile","mkdir","rmdir","unlink","stat","lstat","readdir","readlink","symlink"];function Lr(t,e){if(Fr(e))for(const r of Hr)t[`_${r}`]=e[r].bind(e);else for(const r of Hr)t[`_${r}`]=n(e[r].bind(e));Fr(e)?e.rm?t._rm=e.rm.bind(e):e.rmdir.length>1?t._rm=e.rmdir.bind(e):t._rm=Mr.bind(null,t):e.rm?t._rm=n(e.rm.bind(e)):e.rmdir.length>2?t._rm=n(e.rmdir.bind(e)):t._rm=Mr.bind(null,t)}class zr{constructor(t){if(void 0!==t._original_unwrapped_fs)return t;const e=Object.getOwnPropertyDescriptor(t,"promises");e&&e.enumerable?Lr(this,t.promises):Lr(this,t),this._original_unwrapped_fs=t}async exists(t,e={}){try{return await this._stat(t),!0}catch(t){if("ENOENT"===t.code||"ENOTDIR"===t.code||(t.code||"").includes("ENS"))return!1;throw console.log('Unhandled error in "FileSystem.exists()" function',t),t}}async read(t,e={}){try{let r=await this._readFile(t,e);if("true"===e.autocrlf)try{r=new TextDecoder("utf8",{fatal:!0}).decode(r),r=r.replace(/\r\n/g,"\n"),r=(new TextEncoder).encode(r)}catch(t){}return"string"!=typeof r&&(r=$.from(r)),r}catch(t){return null}}async write(t,e,r={}){try{return void await this._writeFile(t,e,r)}catch(i){await this.mkdir(Xt(t)),await this._writeFile(t,e,r)}}async mkdir(t,e=!1){try{return void await this._mkdir(t)}catch(r){if(null===r)return;if("EEXIST"===r.code)return;if(e)throw r;if("ENOENT"===r.code){const e=Xt(t);if("."===e||"/"===e||e===t)throw r;await this.mkdir(e),await this.mkdir(t,!0)}}}async rm(t){try{await this._unlink(t)}catch(t){if("ENOENT"!==t.code)throw t}}async rmdir(t,e){try{e&&e.recursive?await this._rm(t,e):await this._rmdir(t)}catch(t){if("ENOENT"!==t.code)throw t}}async readdir(t){try{const e=await this._readdir(t);return e.sort(Dt),e}catch(t){return"ENOTDIR"===t.code?null:[]}}async readdirDeep(t){const e=await this._readdir(t);return(await Promise.all(e.map((async e=>{const r=t+"/"+e;return(await this._stat(r)).isDirectory()?this.readdirDeep(r):r})))).reduce(((t,e)=>t.concat(e)),[])}async lstat(t){try{return await this._lstat(t)}catch(t){if("ENOENT"===t.code||(t.code||"").includes("ENS"))return null;throw t}}async readlink(t,e={encoding:"buffer"}){try{const r=await this._readlink(t,e);return $.isBuffer(r)?r:$.from(r)}catch(t){if("ENOENT"===t.code||(t.code||"").includes("ENS"))return null;throw t}}async writelink(t,e){return this._symlink(e.toString("utf8"),t)}}function Wr(t,e){if(void 0===e)throw new dr(t)}async function Yr(t,e){return!(!t&&!e)&&(!(!t||e)||(!(t||!e)||("tree"!==await t.type()||"tree"!==await e.type())&&(await t.type()!==await e.type()||await t.mode()!==await e.mode()||await t.oid()!==await e.oid())))}async function Gr({fs:t,dir:e,gitdir:i=r(e,".git"),commit:a="HEAD",cache:n={}}){try{Wr("fs",t),Wr("dir",e),Wr("gitdir",i);const r=new zr(t),s=[Ir({ref:a}),Tr(),re()];let o=[];await Zt.acquire({fs:r,gitdir:i,cache:n},(async function(t){o=t.unmergedPaths}));const c=await Dr({fs:r,cache:n,dir:e,gitdir:i,trees:s,map:async function(t,[e,r,i]){const a=!await Yr(r,i),n=o.includes(t),s=!await Yr(i,e);if(a||n)return e?{path:t,mode:await e.mode(),oid:await e.oid(),type:await e.type(),content:await e.content()}:void 0;if(s)return!1;throw new br(t)}});await Zt.acquire({fs:r,gitdir:i,cache:n},(async function(t){for(const i of c)if(!1!==i)if(i){if("blob"===i.type){const a=(new TextDecoder).decode(i.content);await r.write(`${e}/${i.path}`,a,{mode:i.mode}),t.insert({filepath:i.path,oid:i.oid,stage:0})}}else await r.rmdir(`${e}/${i.path}`,{recursive:!0}),t.delete({filepath:i.path})}))}catch(t){throw t.caller="git.abortMerge",t}}class qr{static async isIgnored({fs:t,dir:e,gitdir:i=r(e,".git"),filepath:a}){if(".git"===Jt(a))return!0;if("."===a)return!1;let n="";const o=r(i,"info","exclude");await t.exists(o)&&(n=await t.read(o,"utf8"));const c=[{gitignore:r(e,".gitignore"),filepath:a}],f=a.split("/").filter(Boolean);for(let t=1;t<f.length;t++){const i=f.slice(0,t).join("/"),a=f.slice(t).join("/");c.push({gitignore:r(e,i,".gitignore"),filepath:a})}let d=!1;for(const e of c){let r;try{r=await t.read(e.gitignore,"utf8")}catch(t){if("NOENT"===t.code)continue}const i=s().add(n);i.add(r);const a=Xt(e.filepath);if("."!==a&&i.ignores(a))return!0;d=d?!i.test(e.filepath).unignored:i.test(e.filepath).ignored}return d}}let Kr=null;async function Vr(t){return null===Kr&&(Kr=function(){try{new CompressionStream("deflate").writable.close();return new Blob([]).stream().cancel(),!0}catch(t){return!1}}()),Kr?async function(t){const e=new CompressionStream("deflate"),r=new Blob([t]).stream().pipeThrough(e);return new Uint8Array(await new Response(r).arrayBuffer())}(t):a.deflate(t)}async function Zr({fs:t,gitdir:e,type:r,object:i,format:a="content",oid:n,dryRun:s=!1}){return"deflated"!==a&&("wrapped"!==a&&(i=Ce.wrap({type:r,object:i})),n=await Wt(i),i=$.from(await Vr(i))),s||await async function({fs:t,gitdir:e,object:r,format:i,oid:a}){if("deflated"!==i)throw new Bt("GitObjectStoreLoose expects objects to write to be in deflated format");const n=`${e}/objects/${a.slice(0,2)}/${a.slice(2)}`;await t.exists(n)||await t.write(n,r)}({fs:t,gitdir:e,object:i,format:"deflated",oid:n}),n}function Jr(t){let e;for(;~(e=t.indexOf(92));)t[e]=47;return t}async function Xr({fs:t,dir:e,gitdir:i=r(e,".git"),filepath:a,cache:n={},force:s=!1,parallel:o=!0}){try{Wr("fs",t),Wr("dir",e),Wr("gitdir",i),Wr("filepath",a);const r=new zr(t);await Zt.acquire({fs:r,gitdir:i,cache:n},(async t=>{const n=await Se.get({fs:r,gitdir:i}),c=await n.get("core.autocrlf");return Qr({dir:e,gitdir:i,fs:r,filepath:a,index:t,force:s,parallel:o,autocrlf:c})}))}catch(t){throw t.caller="git.add",t}}async function Qr({dir:t,gitdir:e,fs:i,filepath:a,index:n,force:s,parallel:o,autocrlf:c}){const f=(a=Array.isArray(a)?a:[a]).map((async a=>{if(!s){if(await qr.isIgnored({fs:i,dir:t,gitdir:e,filepath:a}))return}const f=await i.lstat(r(t,a));if(!f)throw new ie(a);if(f.isDirectory()){const f=await i.readdir(r(t,a));if(o){const d=f.map((f=>Qr({dir:t,gitdir:e,fs:i,filepath:[r(a,f)],index:n,force:s,parallel:o,autocrlf:c})));await Promise.all(d)}else for(const d of f)await Qr({dir:t,gitdir:e,fs:i,filepath:[r(a,d)],index:n,force:s,parallel:o,autocrlf:c})}else{const s=f.isSymbolicLink()?await i.readlink(r(t,a)).then(Jr):await i.read(r(t,a),{autocrlf:c});if(null===s)throw new ie(a);const o=await Zr({fs:i,gitdir:e,type:"blob",object:s});n.insert({filepath:a,stats:f,oid:o})}})),d=await Promise.allSettled(f),h=d.filter((t=>"rejected"===t.status)).map((t=>t.reason));if(h.length>1)throw new hr(h);if(1===h.length)throw h[0];return d.filter((t=>"fulfilled"===t.status&&t.value)).map((t=>t.value))}async function ti({fs:t,gitdir:e,path:r}){return(await Se.get({fs:t,gitdir:e})).get(r)}function ei(t,...e){for(const r of e)if(r)for(const e of Object.keys(r)){const i=r[e];void 0!==i&&(t[e]=i)}return t}async function ri({fs:t,gitdir:e,author:r,commit:i}){const a=Math.floor(Date.now()/1e3),n=ei({},{name:await ti({fs:t,gitdir:e,path:"user.name"}),email:await ti({fs:t,gitdir:e,path:"user.email"})||"",timestamp:a,timezoneOffset:new Date(1e3*a).getTimezoneOffset()},i?i.author:void 0,r);if(void 0!==n.name)return n}async function ii({fs:t,gitdir:e,author:r,committer:i,commit:a}){const n=Math.floor(Date.now()/1e3),s=ei({},{name:await ti({fs:t,gitdir:e,path:"user.name"}),email:await ti({fs:t,gitdir:e,path:"user.email"})||"",timestamp:n,timezoneOffset:new Date(1e3*n).getTimezoneOffset()},a?a.committer:void 0,r,i);if(void 0!==s.name)return s}async function ai({fs:t,cache:e,gitdir:r,oid:i}){const{type:a,object:n}=await Ve({fs:t,cache:e,gitdir:r,oid:i});if("tag"===a)return ai({fs:t,cache:e,gitdir:r,oid:i=Ar.from(n).parse().object});if("commit"!==a)throw new ae(i,a,"commit");return{commit:Rr.from(n),oid:i}}async function ni({fs:t,cache:e,gitdir:r,oid:i}){const{commit:a,oid:n}=await ai({fs:t,cache:e,gitdir:r,oid:i});return{oid:n,commit:a.parse(),payload:a.withoutSignature()}}async function si({fs:t,cache:e,onSign:r,gitdir:i,message:a,author:n,committer:s,signingKey:o,amend:c=!1,dryRun:f=!1,noUpdateBranch:d=!1,ref:h,parent:u,tree:l}){let g,w,p=!1;h||(h=await je.resolve({fs:t,gitdir:i,ref:"HEAD",depth:2}));try{g=await je.resolve({fs:t,gitdir:i,ref:h}),w=await ni({fs:t,gitdir:i,oid:g,cache:{}})}catch{p=!0}if(c&&p)throw new vr(h);const m=c?await ri({fs:t,gitdir:i,author:n,commit:w.commit}):await ri({fs:t,gitdir:i,author:n});if(!m)throw new fr("author");const y=c?await ii({fs:t,gitdir:i,author:m,committer:s,commit:w.commit}):await ii({fs:t,gitdir:i,author:m,committer:s});if(!y)throw new fr("committer");return Zt.acquire({fs:t,gitdir:i,cache:e,allowUnmerged:!1},(async function(e){const n=Qt(e.entries).get(".");if(l||(l=await oi({fs:t,gitdir:i,inode:n,dryRun:f})),u=u?await Promise.all(u.map((e=>je.resolve({fs:t,gitdir:i,ref:e})))):c?w.commit.parent:g?[g]:[],!a){if(!c)throw new dr("message");a=w.commit.message}let s=Rr.from({tree:l,parent:u,author:m,committer:y,message:a});o&&(s=await Rr.sign(s,r,o));const p=await Zr({fs:t,gitdir:i,type:"commit",object:s.toObject(),dryRun:f});return d||f||await je.writeRef({fs:t,gitdir:i,ref:h,value:p}),p}))}async function oi({fs:t,gitdir:e,inode:r,dryRun:i}){const a=r.children;for(const r of a)"tree"===r.type&&(r.metadata.mode="040000",r.metadata.oid=await oi({fs:t,gitdir:e,inode:r,dryRun:i}));const n=a.map((t=>({mode:t.metadata.mode,path:t.basename,oid:t.metadata.oid,type:t.type}))),s=Ue.from(n);return await Zr({fs:t,gitdir:e,type:"tree",object:s.toObject(),dryRun:i})}async function ci({fs:t,cache:e,gitdir:r,oid:i,filepath:a}){if(a.startsWith("/"))throw new ar("leading-slash");if(a.endsWith("/"))throw new ar("trailing-slash");const n=i,s=await kr({fs:t,cache:e,gitdir:r,oid:i}),o=s.tree;if(""===a)i=s.oid;else{const s=a.split("/");i=await fi({fs:t,cache:e,gitdir:r,tree:o,pathArray:s,oid:n,filepath:a})}return i}async function fi({fs:t,cache:e,gitdir:r,tree:i,pathArray:a,oid:n,filepath:s}){const o=a.shift();for(const c of i)if(c.path===o){if(0===a.length)return c.oid;{const{type:o,object:f}=await Ve({fs:t,cache:e,gitdir:r,oid:c.oid});if("tree"!==o)throw new ae(n,o,"tree",s);return fi({fs:t,cache:e,gitdir:r,tree:i=Ue.from(f),pathArray:a,oid:n,filepath:s})}}throw new ie(`file or directory found at "${n}:${s}"`)}async function di({fs:t,cache:e,gitdir:r,oid:i,filepath:a}){void 0!==a&&(i=await ci({fs:t,cache:e,gitdir:r,oid:i,filepath:a}));const{tree:n,oid:s}=await kr({fs:t,cache:e,gitdir:r,oid:i});return{oid:s,tree:n.entries()}}async function hi({fs:t,gitdir:e,tree:r}){const i=Ue.from(r).toObject();return await Zr({fs:t,gitdir:e,type:"tree",object:i,format:"content"})}async function ui({fs:t,onSign:e,dir:i,gitdir:a=r(i,".git"),ref:n="refs/notes/commits",oid:s,note:o,force:c,author:f,committer:d,signingKey:h,cache:u={}}){try{Wr("fs",t),Wr("gitdir",a),Wr("oid",s),Wr("note",o),h&&Wr("onSign",e);const r=new zr(t),i=await ri({fs:r,gitdir:a,author:f});if(!i)throw new fr("author");const l=await ii({fs:r,gitdir:a,author:i,committer:d});if(!l)throw new fr("committer");return await async function({fs:t,cache:e,onSign:r,gitdir:i,ref:a,oid:n,note:s,force:o,author:c,committer:f,signingKey:d}){let h;try{h=await je.resolve({gitdir:i,fs:t,ref:a})}catch(t){if(!(t instanceof ie))throw t}let u=(await di({fs:t,cache:e,gitdir:i,oid:h||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;if(o)u=u.filter((t=>t.path!==n));else for(const t of u)if(t.path===n)throw new Ze("note",n);"string"==typeof s&&(s=$.from(s,"utf8"));const l=await Zr({fs:t,gitdir:i,type:"blob",object:s,format:"content"});u.push({mode:"100644",path:n,oid:l,type:"blob"});const g=await hi({fs:t,gitdir:i,tree:u});return await si({fs:t,cache:e,onSign:r,gitdir:i,ref:a,tree:g,parent:h&&[h],message:"Note added by 'isomorphic-git addNote'\n",author:c,committer:f,signingKey:d})}({fs:new zr(r),cache:u,onSign:e,gitdir:a,ref:n,oid:s,note:o,force:c,author:i,committer:l,signingKey:h})}catch(t){throw t.caller="git.addNote",t}}async function li({fs:t,gitdir:e,remote:r,url:i,force:a}){if(r!==o.clean(r))throw new nr(r,o.clean(r));const n=await Se.get({fs:t,gitdir:e});if(!a){if((await n.getSubsections("remote")).includes(r)&&i!==await n.get(`remote.${r}.url`))throw new Ze("remote",r)}await n.set(`remote.${r}.url`,i),await n.set(`remote.${r}.fetch`,`+refs/heads/*:refs/remotes/${r}/*`),await Se.save({fs:t,gitdir:e,config:n})}async function gi({fs:t,dir:e,gitdir:i=r(e,".git"),remote:a,url:n,force:s=!1}){try{return Wr("fs",t),Wr("gitdir",i),Wr("remote",a),Wr("url",n),await li({fs:new zr(t),gitdir:i,remote:a,url:n,force:s})}catch(t){throw t.caller="git.addRemote",t}}async function wi({fs:t,onSign:e,dir:i,gitdir:a=r(i,".git"),ref:n,tagger:s,message:o=n,gpgsig:c,object:f,signingKey:d,force:h=!1,cache:u={}}){try{Wr("fs",t),Wr("gitdir",a),Wr("ref",n),d&&Wr("onSign",e);const r=new zr(t),i=await ri({fs:r,gitdir:a,author:s});if(!i)throw new fr("tagger");return await async function({fs:t,cache:e,onSign:r,gitdir:i,ref:a,tagger:n,message:s=a,gpgsig:o,object:c,signingKey:f,force:d=!1}){if(a=a.startsWith("refs/tags/")?a:`refs/tags/${a}`,!d&&await je.exists({fs:t,gitdir:i,ref:a}))throw new Ze("tag",a);const h=await je.resolve({fs:t,gitdir:i,ref:c||"HEAD"}),{type:u}=await Ve({fs:t,cache:e,gitdir:i,oid:h});let l=Ar.from({object:h,type:u,tag:a.replace("refs/tags/",""),tagger:n,message:s,gpgsig:o});f&&(l=await Ar.sign(l,r,f));const g=await Zr({fs:t,gitdir:i,type:"tag",object:l.toObject()});await je.writeRef({fs:t,gitdir:i,ref:a,value:g})}({fs:r,cache:u,onSign:e,gitdir:a,ref:n,tagger:i,message:o,gpgsig:c,object:f,signingKey:d,force:h})}catch(t){throw t.caller="git.annotatedTag",t}}async function pi({fs:t,dir:e,gitdir:i=r(e,".git"),ref:a,object:n,checkout:s=!1,force:c=!1}){try{return Wr("fs",t),Wr("gitdir",i),Wr("ref",a),await async function({fs:t,gitdir:e,ref:r,object:i,checkout:a=!1,force:n=!1}){if(r!==o.clean(r))throw new nr(r,o.clean(r));const s=`refs/heads/${r}`;if(!n&&await je.exists({fs:t,gitdir:e,ref:s}))throw new Ze("branch",r,!1);let c;try{c=await je.resolve({fs:t,gitdir:e,ref:i||"HEAD"})}catch(t){}c&&await je.writeRef({fs:t,gitdir:e,ref:s,value:c}),a&&await je.writeSymbolicRef({fs:t,gitdir:e,ref:"HEAD",value:s})}({fs:new zr(t),gitdir:i,ref:a,object:n,checkout:s,force:c})}catch(t){throw t.caller="git.branch",t}}const mi=(t,e)=>"."===t||null==e||0===e.length||"."===e||(e.length>=t.length?e.startsWith(t):t.startsWith(e));async function yi({fs:t,cache:e,onProgress:r,onPostCheckout:i,dir:a,gitdir:n,remote:s,ref:o,filepaths:c,noCheckout:f,noUpdateHead:d,dryRun:h,force:u,track:l=!0}){let g,w;if(i)try{g=await je.resolve({fs:t,gitdir:n,ref:"HEAD"})}catch(t){g="0000000000000000000000000000000000000000"}try{w=await je.resolve({fs:t,gitdir:n,ref:o})}catch(e){if("HEAD"===o)throw e;const r=`${s}/${o}`;if(w=await je.resolve({fs:t,gitdir:n,ref:r}),l){const e=await Se.get({fs:t,gitdir:n});await e.set(`branch.${o}.remote`,s),await e.set(`branch.${o}.merge`,`refs/heads/${o}`),await Se.save({fs:t,gitdir:n,config:e})}await je.writeRef({fs:t,gitdir:n,ref:`refs/heads/${o}`,value:w})}if(!f){let s;try{s=await async function({fs:t,cache:e,onProgress:r,dir:i,gitdir:a,ref:n,force:s,filepaths:o}){let c=0;return Dr({fs:t,cache:e,dir:i,gitdir:a,trees:[Ir({ref:n}),Tr(),re()],map:async function(t,[e,i,a]){if("."===t)return;if(o&&!o.some((e=>mi(t,e))))return null;r&&await r({phase:"Analyzing workdir",loaded:++c});switch([!!a,!!e,!!i].map(Number).join("")){case"000":return;case"001":return s&&o&&o.includes(t)?["delete",t]:void 0;case"010":switch(await e.type()){case"tree":return["mkdir",t];case"blob":return["create",t,await e.oid(),await e.mode()];case"commit":return["mkdir-index",t,await e.oid(),await e.mode()];default:return["error",`new entry Unhandled type ${await e.type()}`]}case"011":switch(`${await e.type()}-${await i.type()}`){case"tree-tree":case"commit-tree":return;case"tree-blob":case"blob-tree":case"commit-blob":return["conflict",t];case"blob-blob":return await e.oid()!==await i.oid()?s?["update",t,await e.oid(),await e.mode(),await e.mode()!==await i.mode()]:["conflict",t]:await e.mode()!==await i.mode()?s?["update",t,await e.oid(),await e.mode(),!0]:["conflict",t]:["create-index",t,await e.oid(),await e.mode()];default:return["error",`new entry Unhandled type ${e.type}`]}case"100":return["delete-index",t];case"101":switch(await a.type()){case"tree":return["rmdir",t];case"blob":return await a.oid()!==await i.oid()?s?["delete",t]:["conflict",t]:["delete",t];case"commit":return["rmdir-index",t];default:return["error",`delete entry Unhandled type ${await a.type()}`]}case"110":case"111":switch(`${await a.type()}-${await e.type()}`){case"tree-tree":return;case"blob-blob":if(await a.oid()===await e.oid()&&await a.mode()===await e.mode()&&!s)return;if(i){if(await i.oid()!==await a.oid()&&await i.oid()!==await e.oid())return s?["update",t,await e.oid(),await e.mode(),await e.mode()!==await i.mode()]:["conflict",t]}else if(s)return["update",t,await e.oid(),await e.mode(),await e.mode()!==await a.mode()];return await e.mode()!==await a.mode()?["update",t,await e.oid(),await e.mode(),!0]:await e.oid()!==await a.oid()?["update",t,await e.oid(),await e.mode(),!1]:void 0;case"tree-blob":return["update-dir-to-blob",t,await e.oid()];case"blob-tree":return["update-blob-to-tree",t];case"commit-commit":return["mkdir-index",t,await e.oid(),await e.mode()];default:return["error",`update entry Unhandled type ${await a.type()}-${await e.type()}`]}}},reduce:async function(t,e){return e=Br(e),t?t&&"rmdir"===t[0]?(e.push(t),e):(e.unshift(t),e):e}})}({fs:t,cache:e,onProgress:r,dir:a,gitdir:n,ref:o,force:u,filepaths:c})}catch(t){throw t instanceof ie&&t.data.what===w?new Qe(o,w):t}const f=s.filter((([t])=>"conflict"===t)).map((([t,e])=>e));if(f.length>0)throw new Xe(f);const d=s.filter((([t])=>"error"===t)).map((([t,e])=>e));if(d.length>0)throw new Bt(d.join(", "));if(h)return void(i&&await i({previousHead:g,newHead:w,type:null!=c&&c.length>0?"file":"branch"}));let l=0;const p=s.length;await Zt.acquire({fs:t,gitdir:n,cache:e},(async function(e){await Promise.all(s.filter((([t])=>"delete"===t||"delete-index"===t)).map((async function([i,n]){const s=`${a}/${n}`;"delete"===i&&await t.rm(s),e.delete({filepath:n}),r&&await r({phase:"Updating workdir",loaded:++l,total:p})})))})),await Zt.acquire({fs:t,gitdir:n,cache:e},(async function(e){for(const[i,n]of s)if("rmdir"===i||"rmdir-index"===i){const s=`${a}/${n}`;try{"rmdir-index"===i&&e.delete({filepath:n}),await t.rmdir(s),r&&await r({phase:"Updating workdir",loaded:++l,total:p})}catch(t){if("ENOTEMPTY"!==t.code)throw t;console.log(`Did not delete ${n} because directory is not empty`)}}})),await Promise.all(s.filter((([t])=>"mkdir"===t||"mkdir-index"===t)).map((async function([e,i]){const n=`${a}/${i}`;await t.mkdir(n),r&&await r({phase:"Updating workdir",loaded:++l,total:p})}))),await Zt.acquire({fs:t,gitdir:n,cache:e},(async function(i){await Promise.all(s.filter((([t])=>"create"===t||"create-index"===t||"update"===t||"mkdir-index"===t)).map((async function([s,o,c,f,d]){const h=`${a}/${o}`;try{if("create-index"!==s&&"mkdir-index"!==s){const{object:r}=await Ve({fs:t,cache:e,gitdir:n,oid:c});if(d&&await t.rm(h),33188===f)await t.write(h,r);else if(33261===f)await t.write(h,r,{mode:511});else{if(40960!==f)throw new Bt(`Invalid mode 0o${f.toString(8)} detected in blob ${c}`);await t.writelink(h,r)}}const a=await t.lstat(h);33261===f&&(a.mode=493),"mkdir-index"===s&&(a.mode=57344),i.insert({filepath:o,stats:a,oid:c}),r&&await r({phase:"Updating workdir",loaded:++l,total:p})}catch(t){console.log(t)}})))})),i&&await i({previousHead:g,newHead:w,type:null!=c&&c.length>0?"file":"branch"})}if(!d){const e=await je.expand({fs:t,gitdir:n,ref:o});e.startsWith("refs/heads")?await je.writeSymbolicRef({fs:t,gitdir:n,ref:"HEAD",value:e}):await je.writeRef({fs:t,gitdir:n,ref:"HEAD",value:w})}}async function bi({fs:t,onProgress:e,onPostCheckout:i,dir:a,gitdir:n=r(a,".git"),remote:s="origin",ref:o,filepaths:c,noCheckout:f=!1,noUpdateHead:d=void 0===o,dryRun:h=!1,force:u=!1,track:l=!0,cache:g={}}){try{Wr("fs",t),Wr("dir",a),Wr("gitdir",n);const r=o||"HEAD";return await yi({fs:new zr(t),cache:g,onProgress:e,onPostCheckout:i,dir:a,gitdir:n,remote:s,ref:r,filepaths:c,noCheckout:f,noUpdateHead:d,dryRun:h,force:u,track:l})}catch(t){throw t.caller="git.checkout",t}}const vi=new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");function xi(t){const e=vi.exec(t);return e?"remotes/"===e[1]&&t.endsWith("/HEAD")?e[2].slice(0,-5):e[2]:t}async function Ei({fs:t,gitdir:e,fullname:r=!1,test:i=!1}){const a=await je.resolve({fs:t,gitdir:e,ref:"HEAD",depth:2});if(i)try{await je.resolve({fs:t,gitdir:e,ref:a})}catch(t){return}if(a.startsWith("refs/"))return r?a:xi(a)}function _i({username:t="",password:e=""}){return`Basic ${$.from(`${t}:${e}`).toString("base64")}`}async function $i(t,e){const r=He(t);for(;;){const{value:t,done:i}=await r.next();if(t&&await e(t),i)break}r.return&&r.return()}async function Si(t){let e=0;const r=[];await $i(t,(t=>{r.push(t),e+=t.byteLength}));const i=new Uint8Array(e);let a=0;for(const t of r)i.set(t,a),a+=t.byteLength;return i}function Ai(t){let e=t.match(/^https?:\/\/([^/]+)@/);if(null==e)return{url:t,auth:{}};e=e[1];const[r,i]=e.split(":");return{url:t=t.replace(`${e}@`,""),auth:{username:r,password:i}}}function Pi(t,e){const r=e.toString(16);return"0".repeat(t-r.length)+r}class Ri{static flush(){return $.from("0000","utf8")}static delim(){return $.from("0001","utf8")}static encode(t){"string"==typeof t&&(t=$.from(t));const e=Pi(4,t.length+4);return $.concat([$.from(e,"utf8"),t])}static streamReader(t){const e=new Le(t);return async function(){try{let t=await e.read(4);if(null==t)return!0;if(t=parseInt(t.toString("utf8"),16),0===t)return null;if(1===t)return null;const r=await e.read(t-4);return null==r||r}catch(e){return t.error=e,!0}}}}async function ki(t){const e={};let r;for(;r=await t(),!0!==r;){if(null===r)continue;r=r.toString("utf8").replace(/\n$/,"");const t=r.indexOf("=");if(t>-1){const i=r.slice(0,t),a=r.slice(t+1);e[i]=a}else e[r]=!0}return{protocolVersion:2,capabilities2:e}}async function ji(t,{service:e}){const r=new Set,i=new Map,a=new Map,n=Ri.streamReader(t);let s=await n();for(;null===s;)s=await n();if(!0===s)throw new tr;if(s.includes("version 2"))return ki(n);if(s.toString("utf8").replace(/\n$/,"")!==`# service=${e}`)throw new ur(`# service=${e}\\n`,s.toString("utf8"));let o=await n();for(;null===o;)o=await n();if(!0===o)return{capabilities:r,refs:i,symrefs:a};if(o=o.toString("utf8"),o.includes("version 2"))return ki(n);const[c,f]=Ii(o,"\0","\\x00");if(f.split(" ").map((t=>r.add(t))),"0000000000000000000000000000000000000000 capabilities^{}"!==c){const[t,e]=Ii(c," "," ");for(i.set(e,t);;){const t=await n();if(!0===t)break;if(null!==t){const[e,r]=Ii(t.toString("utf8")," "," ");i.set(r,e)}}}for(const t of r)if(t.startsWith("symref=")){const e=t.match(/symref=([^:]+):(.*)/);3===e.length&&a.set(e[1],e[2])}return{protocolVersion:1,capabilities:r,refs:i,symrefs:a}}function Ii(t,e,r){const i=t.trim().split(e);if(2!==i.length)throw new ur(`Two strings separated by '${r}'`,t.toString("utf8"));return i}const Oi=(t,e)=>t.endsWith("?")?`${t}${e}`:`${t}/${e.replace(/^https?:\/\//,"")}`,Ti=(t,e)=>{(e.username||e.password)&&(t.Authorization=_i(e)),e.headers&&Object.assign(t,e.headers)},Bi=async t=>{try{const e=$.from(await Si(t.body)),r=e.toString("utf8");return{preview:r.length<256?r:r.slice(0,256)+"...",response:r,data:e}}catch(t){return{}}};class Ui{static async capabilities(){return["discover","connect"]}static async discover({http:t,onProgress:e,onAuth:r,onAuthSuccess:i,onAuthFailure:a,corsProxy:n,service:s,url:o,headers:c,protocolVersion:f}){let{url:d,auth:h}=Ai(o);const u=n?Oi(n,d):d;let l,g;(h.username||h.password)&&(c.Authorization=_i(h)),2===f&&(c["Git-Protocol"]="version=2");let w=!1;do{if(l=await t.request({onProgress:e,method:"GET",url:`${u}/info/refs?service=${s}`,headers:c}),g=!1,401===l.statusCode||203===l.statusCode){const t=w?a:r;if(t){if(h=await t(d,{...h,headers:{...c}}),h&&h.cancel)throw new yr;h&&(Ti(c,h),w=!0,g=!0)}}else 200===l.statusCode&&w&&i&&await i(d,h)}while(g);if(200!==l.statusCode){const{response:t}=await Bi(l);throw new ir(l.statusCode,l.statusMessage,t)}if(l.headers["content-type"]===`application/x-${s}-advertisement`){const t=await ji(l.body,{service:s});return t.auth=h,t}{const{preview:t,response:e,data:r}=await Bi(l);try{const t=await ji([r],{service:s});return t.auth=h,t}catch(r){throw new wr(t,e)}}}static async connect({http:t,onProgress:e,corsProxy:r,service:i,url:a,auth:n,body:s,headers:o}){const c=Ai(a);c&&(a=c.url),r&&(a=Oi(r,a)),o["content-type"]=`application/x-${i}-request`,o.accept=`application/x-${i}-result`,Ti(o,n);const f=await t.request({onProgress:e,method:"POST",url:`${a}/${i}`,body:s,headers:o});if(200!==f.statusCode){const{response:t}=Bi(f);throw new ir(f.statusCode,f.statusMessage,t)}return f}}class Ci{static getRemoteHelperFor({url:t}){const e=new Map;e.set("http",Ui),e.set("https",Ui);const r=function({url:t}){if(t.startsWith("git@"))return{transport:"ssh",address:t};const e=t.match(/(\w+)(:\/\/|::)(.*)/);return null!==e?"://"===e[2]?{transport:e[1],address:e[0]}:"::"===e[2]?{transport:e[1],address:e[3]}:void 0:void 0}({url:t});if(!r)throw new mr(t);if(e.has(r.transport))return e.get(r.transport);throw new pr(t,r.transport,"ssh"===r.transport?function(t){return(t=t.replace(/^git@([^:]+):/,"https://$1/")).replace(/^ssh:\/\//,"https://")}(t):void 0)}}let Di=null;class Mi{static async read({fs:e,gitdir:i}){null===Di&&(Di=new t);const a=r(i,"shallow"),n=new Set;return await Di.acquire(a,(async function(){const t=await e.read(a,{encoding:"utf8"});return null===t||""===t.trim()?n:void t.trim().split("\n").map((t=>n.add(t)))})),n}static async write({fs:e,gitdir:i,oids:a}){null===Di&&(Di=new t);const n=r(i,"shallow");if(a.size>0){const t=[...a].join("\n")+"\n";await Di.acquire(n,(async function(){await e.write(n,t,{encoding:"utf8"})}))}else await Di.acquire(n,(async function(){await e.rm(n)}))}}async function Ni({fs:t,cache:e,gitdir:i,oid:a,format:n="content"}){const s=r=>Ve({fs:t,cache:e,gitdir:i,oid:r});let o=await async function({fs:t,gitdir:e,oid:r}){const i=`objects/${r.slice(0,2)}/${r.slice(2)}`;return t.exists(`${e}/${i}`)}({fs:t,gitdir:i,oid:a});return o||(o=await async function({fs:t,cache:e,gitdir:i,oid:a,getExternalRefDelta:n}){let s=await t.readdir(r(i,"objects/pack"));s=s.filter((t=>t.endsWith(".idx")));for(const r of s){const s=`${i}/objects/pack/${r}`,o=await Ke({fs:t,cache:e,filename:s,getExternalRefDelta:n});if(o.error)throw new Bt(o.error);if(o.offsets.has(a))return!0}return!1}({fs:t,cache:e,gitdir:i,oid:a,getExternalRefDelta:s})),o}function Fi(t,e){const r=t.map((t=>t.split("=",1)[0]));return e.filter((t=>{const e=t.split("=",1)[0];return r.includes(e)}))}const Hi="1.30.1",Li="git/isomorphic-git@1.30.1";class zi{constructor(){this._queue=[]}write(t){if(this._ended)throw Error("You cannot write to a FIFO that has already been ended!");if(this._waiting){const e=this._waiting;this._waiting=null,e({value:t})}else this._queue.push(t)}end(){if(this._ended=!0,this._waiting){const t=this._waiting;this._waiting=null,t({done:!0})}}destroy(t){this.error=t,this.end()}async next(){if(this._queue.length>0)return{value:this._queue.shift()};if(this._ended)return{done:!0};if(this._waiting)throw Error("You cannot call read until the previous call to read has returned!");return new Promise((t=>{this._waiting=t}))}}function Wi(t){const e=t.indexOf("\r"),r=t.indexOf("\n");return-1===e&&-1===r?-1:-1===e?r+1:-1===r?e+1:r===e+1?r+1:Math.min(e,r)+1}function Yi(t){const e=new zi;let r="";return(async()=>{await $i(t,(t=>{for(t=t.toString("utf8"),r+=t;;){const t=Wi(r);if(-1===t)break;e.write(r.slice(0,t)),r=r.slice(t)}})),r.length>0&&e.write(r),e.end()})(),e}class Gi{static demux(t){const e=Ri.streamReader(t),r=new zi,i=new zi,a=new zi,n=async function(){const s=await e();if(null===s)return n();if(!0===s)return r.end(),a.end(),void(t.error?i.destroy(t.error):i.end());switch(s[0]){case 1:i.write(s.slice(1));break;case 2:a.write(s.slice(1));break;case 3:{const t=s.slice(1);return a.write(t),r.end(),a.end(),void i.destroy(new Error(t.toString("utf8")))}default:r.write(s)}n()};return n(),{packetlines:r,packfile:i,progress:a}}}async function qi({fs:t,cache:e,http:i,onProgress:a,onMessage:n,onAuth:s,onAuthSuccess:o,onAuthFailure:c,gitdir:f,ref:d,remoteRef:h,remote:u,url:l,corsProxy:g,depth:w=null,since:p=null,exclude:m=[],relative:y=!1,tags:b=!1,singleBranch:v=!1,headers:x={},prune:E=!1,pruneTags:_=!1}){const S=d||await Ei({fs:t,gitdir:f,test:!0}),A=await Se.get({fs:t,gitdir:f}),P=u||S&&await A.get(`branch.${S}.remote`)||"origin",R=l||await A.get(`remote.${P}.url`);if(void 0===R)throw new dr("remote OR url");const k=h||S&&await A.get(`branch.${S}.merge`)||d||"HEAD";void 0===g&&(g=await A.get("http.corsProxy"));const j=Ci.getRemoteHelperFor({url:R}),I=await j.discover({http:i,onAuth:s,onAuthSuccess:o,onAuthFailure:c,corsProxy:g,service:"git-upload-pack",url:R,headers:x,protocolVersion:1}),O=I.auth,T=I.refs;if(0===T.size)return{defaultBranch:null,fetchHead:null,fetchHeadDescription:null};if(null!==w&&!I.capabilities.has("shallow"))throw new gr("shallow","depth");if(null!==p&&!I.capabilities.has("deepen-since"))throw new gr("deepen-since","since");if(m.length>0&&!I.capabilities.has("deepen-not"))throw new gr("deepen-not","exclude");if(!0===y&&!I.capabilities.has("deepen-relative"))throw new gr("deepen-relative","relative");const{oid:B,fullref:U}=je.resolveAgainstMap({ref:k,map:T});for(const t of T.keys())t===U||"HEAD"===t||t.startsWith("refs/heads/")||b&&t.startsWith("refs/tags/")||T.delete(t);const C=Fi([...I.capabilities],["multi_ack_detailed","no-done","side-band-64k","ofs-delta",`agent=${Li}`]);y&&C.push("deepen-relative");const D=v?[B]:T.values(),M=v?[S]:await je.listRefs({fs:t,gitdir:f,filepath:"refs"});let N=[];for(let r of M)try{r=await je.expand({fs:t,gitdir:f,ref:r});const i=await je.resolve({fs:t,gitdir:f,ref:r});await Ni({fs:t,cache:e,gitdir:f,oid:i})&&N.push(i)}catch(t){}N=[...new Set(N)];const F=await Mi.read({fs:t,gitdir:f}),H=function({capabilities:t=[],wants:e=[],haves:r=[],shallows:i=[],depth:a=null,since:n=null,exclude:s=[]}){const o=[];e=[...new Set(e)];let c=` ${t.join(" ")}`;for(const t of e)o.push(Ri.encode(`want ${t}${c}\n`)),c="";for(const t of i)o.push(Ri.encode(`shallow ${t}\n`));null!==a&&o.push(Ri.encode(`deepen ${a}\n`)),null!==n&&o.push(Ri.encode(`deepen-since ${Math.floor(n.valueOf()/1e3)}\n`));for(const t of s)o.push(Ri.encode(`deepen-not ${t}\n`));o.push(Ri.flush());for(const t of r)o.push(Ri.encode(`have ${t}\n`));return o.push(Ri.encode("done\n")),o}({capabilities:C,wants:D,haves:N,shallows:I.capabilities.has("shallow")?[...F]:[],depth:w,since:p,exclude:m}),L=$.from(await Si(H)),z=await j.connect({http:i,onProgress:a,corsProxy:g,service:"git-upload-pack",url:R,auth:O,body:[L],headers:x}),W=await async function(t){const{packetlines:e,packfile:r,progress:i}=Gi.demux(t),a=[],n=[],s=[];let o=!1,c=!1;return new Promise(((f,d)=>{$i(e,(e=>{const h=e.toString("utf8").trim();if(h.startsWith("shallow")){const t=h.slice(-41).trim();40!==t.length&&d(new ne(t)),a.push(t)}else if(h.startsWith("unshallow")){const t=h.slice(-41).trim();40!==t.length&&d(new ne(t)),n.push(t)}else if(h.startsWith("ACK")){const[,t,e]=h.split(" ");s.push({oid:t,status:e}),e||(c=!0)}else h.startsWith("NAK")?(o=!0,c=!0):(c=!0,o=!0);c&&(t.error?d(t.error):f({shallows:a,unshallows:n,acks:s,nak:o,packfile:r,progress:i}))})).finally((()=>{c||(t.error?d(t.error):f({shallows:a,unshallows:n,acks:s,nak:o,packfile:r,progress:i}))}))}))}(z.body);z.headers&&(W.headers=z.headers);for(const r of W.shallows)if(!F.has(r))try{const{object:i}=await Ve({fs:t,cache:e,gitdir:f,oid:r}),a=new Rr(i),n=await Promise.all(a.headers().parent.map((r=>Ni({fs:t,cache:e,gitdir:f,oid:r}))));0===n.length||n.every((t=>t))||F.add(r)}catch(t){F.add(r)}for(const t of W.unshallows)F.delete(t);if(await Mi.write({fs:t,gitdir:f,oids:F}),v){const e=new Map([[U,B]]),r=new Map;let i=10,a=U;for(;i--;){const t=I.symrefs.get(a);if(void 0===t)break;r.set(a,t),a=t}const n=T.get(a);n&&e.set(a,n);const{pruned:s}=await je.updateRemoteRefs({fs:t,gitdir:f,remote:P,refs:e,symrefs:r,tags:b,prune:E});E&&(W.pruned=s)}else{const{pruned:e}=await je.updateRemoteRefs({fs:t,gitdir:f,remote:P,refs:T,symrefs:I.symrefs,tags:b,prune:E,pruneTags:_});E&&(W.pruned=e)}if(W.HEAD=I.symrefs.get("HEAD"),void 0===W.HEAD){const{oid:t}=je.resolveAgainstMap({ref:"HEAD",map:T});for(const[e,r]of T.entries())if("HEAD"!==e&&r===t){W.HEAD=e;break}}const Y=U.startsWith("refs/tags")?"tag":"branch";if(W.FETCH_HEAD={oid:B,description:`${Y} '${xi(U)}' of ${R}`},a||n){$i(Yi(W.progress),(async t=>{if(n&&await n(t),a){const e=t.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);e&&await a({phase:e[1].trim(),loaded:parseInt(e[2],10),total:parseInt(e[3],10)})}}))}const G=$.from(await Si(W.packfile));if(z.body.error)throw z.body.error;const q=G.slice(-20).toString("hex"),K={defaultBranch:W.HEAD,fetchHead:W.FETCH_HEAD.oid,fetchHeadDescription:W.FETCH_HEAD.description};if(W.headers&&(K.headers=W.headers),E&&(K.pruned=W.pruned),""!==q&&"5041434b0000000200000000"!==G.slice(0,12).toString("hex")){K.packfile=`objects/pack/pack-${q}.pack`;const i=r(f,K.packfile);await t.write(i,G);const n=r=>Ve({fs:t,cache:e,gitdir:f,oid:r}),s=await Ge.fromPack({pack:G,getExternalRefDelta:n,onProgress:a});await t.write(i.replace(/\.pack$/,".idx"),await s.toBuffer())}return K}async function Ki({fs:t,bare:e=!1,dir:i,gitdir:a=(e?i:r(i,".git")),defaultBranch:n="master"}){if(await t.exists(a+"/config"))return;let s=["hooks","info","objects/info","objects/pack","refs/heads","refs/tags"];s=s.map((t=>a+"/"+t));for(const e of s)await t.mkdir(e);await t.write(a+"/config",`[core]\n\trepositoryformatversion = 0\n\tfilemode = false\n\tbare = ${e}\n`+(e?"":"\tlogallrefupdates = true\n")+"\tsymlinks = false\n\tignorecase = true\n"),await t.write(a+"/HEAD",`ref: refs/heads/${n}\n`)}async function Vi({fs:t,http:e,onProgress:i,onMessage:a,onAuth:n,onAuthSuccess:s,onAuthFailure:o,onPostCheckout:c,dir:f,gitdir:d=r(f,".git"),url:h,corsProxy:u,ref:l,remote:g="origin",depth:w,since:p,exclude:m=[],relative:y=!1,singleBranch:b=!1,noCheckout:v=!1,noTags:x=!1,headers:E={},cache:_={}}){try{return Wr("fs",t),Wr("http",e),Wr("gitdir",d),v||Wr("dir",f),Wr("url",h),await async function({fs:t,cache:e,http:r,onProgress:i,onMessage:a,onAuth:n,onAuthSuccess:s,onAuthFailure:o,onPostCheckout:c,dir:f,gitdir:d,url:h,corsProxy:u,ref:l,remote:g,depth:w,since:p,exclude:m,relative:y,singleBranch:b,noCheckout:v,noTags:x,headers:E}){try{if(await Ki({fs:t,gitdir:d}),await li({fs:t,gitdir:d,remote:g,url:h,force:!1}),u){const e=await Se.get({fs:t,gitdir:d});await e.set("http.corsProxy",u),await Se.save({fs:t,gitdir:d,config:e})}const{defaultBranch:_,fetchHead:$}=await qi({fs:t,cache:e,http:r,onProgress:i,onMessage:a,onAuth:n,onAuthSuccess:s,onAuthFailure:o,gitdir:d,ref:l,remote:g,corsProxy:u,depth:w,since:p,exclude:m,relative:y,singleBranch:b,headers:E,tags:!x});if(null===$)return;l=(l=l||_).replace("refs/heads/",""),await yi({fs:t,cache:e,onProgress:i,onPostCheckout:c,dir:f,gitdir:d,ref:l,remote:g,noCheckout:v})}catch(e){throw await t.rmdir(d,{recursive:!0,maxRetries:10}).catch((()=>{})),e}}({fs:new zr(t),cache:_,http:e,onProgress:i,onMessage:a,onAuth:n,onAuthSuccess:s,onAuthFailure:o,onPostCheckout:c,dir:f,gitdir:d,url:h,corsProxy:u,ref:l,remote:g,depth:w,since:p,exclude:m,relative:y,singleBranch:b,noCheckout:v,noTags:x,headers:E})}catch(t){throw t.caller="git.clone",t}}async function Zi({fs:t,onSign:e,dir:i,gitdir:a=r(i,".git"),message:n,author:s,committer:o,signingKey:c,amend:f=!1,dryRun:d=!1,noUpdateBranch:h=!1,ref:u,parent:l,tree:g,cache:w={}}){try{Wr("fs",t),f||Wr("message",n),c&&Wr("onSign",e);const r=new zr(t);return await si({fs:r,cache:w,onSign:e,gitdir:a,message:n,author:s,committer:o,signingKey:c,amend:f,dryRun:d,noUpdateBranch:h,ref:u,parent:l,tree:g})}catch(t){throw t.caller="git.commit",t}}async function Ji({fs:t,dir:e,gitdir:i=r(e,".git"),fullname:a=!1,test:n=!1}){try{return Wr("fs",t),Wr("gitdir",i),await Ei({fs:new zr(t),gitdir:i,fullname:a,test:n})}catch(t){throw t.caller="git.currentBranch",t}}async function Xi({fs:t,dir:e,gitdir:i=r(e,".git"),ref:a}){try{return Wr("fs",t),Wr("ref",a),await async function({fs:t,gitdir:e,ref:r}){if(r=r.startsWith("refs/heads/")?r:`refs/heads/${r}`,!await je.exists({fs:t,gitdir:e,ref:r}))throw new ie(r);const i=await je.expand({fs:t,gitdir:e,ref:r});if(i===await Ei({fs:t,gitdir:e,fullname:!0})){const r=await je.resolve({fs:t,gitdir:e,ref:i});await je.writeRef({fs:t,gitdir:e,ref:"HEAD",value:r})}await je.deleteRef({fs:t,gitdir:e,ref:i});const a=xi(r),n=await Se.get({fs:t,gitdir:e});await n.deleteSection("branch",a),await Se.save({fs:t,gitdir:e,config:n})}({fs:new zr(t),gitdir:i,ref:a})}catch(t){throw t.caller="git.deleteBranch",t}}async function Qi({fs:t,dir:e,gitdir:i=r(e,".git"),ref:a}){try{Wr("fs",t),Wr("ref",a),await je.deleteRef({fs:new zr(t),gitdir:i,ref:a})}catch(t){throw t.caller="git.deleteRef",t}}async function ta({fs:t,dir:e,gitdir:i=r(e,".git"),remote:a}){try{return Wr("fs",t),Wr("remote",a),await async function({fs:t,gitdir:e,remote:r}){const i=await Se.get({fs:t,gitdir:e});await i.deleteSection("remote",r),await Se.save({fs:t,gitdir:e,config:i})}({fs:new zr(t),gitdir:i,remote:a})}catch(t){throw t.caller="git.deleteRemote",t}}async function ea({fs:t,dir:e,gitdir:i=r(e,".git"),ref:a}){try{return Wr("fs",t),Wr("ref",a),await async function({fs:t,gitdir:e,ref:r}){r=r.startsWith("refs/tags/")?r:`refs/tags/${r}`,await je.deleteRef({fs:t,gitdir:e,ref:r})}({fs:new zr(t),gitdir:i,ref:a})}catch(t){throw t.caller="git.deleteTag",t}}async function ra({fs:t,cache:e,gitdir:i,oid:a}){const n=await async function({fs:t,gitdir:e,oid:r}){const i=r.slice(0,2);return(await t.readdir(`${e}/objects/${i}`)).map((t=>`${i}${t}`)).filter((t=>t.startsWith(r)))}({fs:t,gitdir:i,oid:a}),s=await async function({fs:t,cache:e,gitdir:i,oid:a,getExternalRefDelta:n}){const s=[];let o=await t.readdir(r(i,"objects/pack"));o=o.filter((t=>t.endsWith(".idx")));for(const r of o){const o=`${i}/objects/pack/${r}`,c=await Ke({fs:t,cache:e,filename:o,getExternalRefDelta:n});if(c.error)throw new Bt(c.error);for(const t of c.offsets.keys())t.startsWith(a)&&s.push(t)}return s}({fs:t,cache:e,gitdir:i,oid:a,getExternalRefDelta:r=>Ve({fs:t,cache:e,gitdir:i,oid:r})});for(const t of s)-1===n.indexOf(t)&&n.push(t);if(1===n.length)return n[0];if(n.length>1)throw new Je("oids",a,n);throw new ie(`an object matching "${a}"`)}async function ia({fs:t,dir:e,gitdir:i=r(e,".git"),oid:a,cache:n={}}){try{return Wr("fs",t),Wr("gitdir",i),Wr("oid",a),await ra({fs:new zr(t),cache:n,gitdir:i,oid:a})}catch(t){throw t.caller="git.expandOid",t}}async function aa({fs:t,dir:e,gitdir:i=r(e,".git"),ref:a}){try{return Wr("fs",t),Wr("gitdir",i),Wr("ref",a),await je.expand({fs:new zr(t),gitdir:i,ref:a})}catch(t){throw t.caller="git.expandRef",t}}async function na({fs:t,cache:e,gitdir:r,oids:i}){const a={},n=i.length;let s=i.map(((t,e)=>({index:e,oid:t})));for(;s.length;){const i=new Set;for(const{oid:t,index:e}of s)a[t]||(a[t]=new Set),a[t].add(e),a[t].size===n&&i.add(t);if(i.size>0)return[...i];const o=new Map;for(const{oid:i,index:n}of s)try{const{object:s}=await Ve({fs:t,cache:e,gitdir:r,oid:i}),c=Rr.from(s),{parent:f}=c.parseHeaders();for(const t of f)a[t]&&a[t].has(n)||o.set(t+":"+n,{oid:t,index:n})}catch(t){}s=Array.from(o.values())}return[]}const sa=/^.*(\r?\n|$)/gm;function oa({branches:t,contents:e}){const r=t[1],i=t[2],a=e[0],n=e[1],s=e[2],o=n.match(sa),f=a.match(sa),d=s.match(sa),h=c(o,f,d);let u="",l=!0;for(const t of h)t.ok&&(u+=t.ok.join("")),t.conflict&&(l=!1,u+=`${"<".repeat(7)} ${r}\n`,u+=t.conflict.a.join(""),u+=`${"=".repeat(7)}\n`,u+=t.conflict.b.join(""),u+=`${">".repeat(7)} ${i}\n`);return{cleanMerge:l,mergedText:u}}async function ca({fs:t,cache:e,dir:i,gitdir:a=r(i,".git"),index:n,ourOid:s,baseOid:o,theirOid:c,ourName:f="ours",baseName:d="base",theirName:h="theirs",dryRun:u=!1,abortOnConflict:l=!0,mergeDriver:g}){const w=Ir({ref:s}),p=Ir({ref:o}),m=Ir({ref:c}),y=[],b=[],v=[],x=[],E=await Dr({fs:t,cache:e,dir:i,gitdir:a,trees:[w,p,m],map:async function(e,[r,i,s]){const o=Jt(e);switch(`${await Yr(r,i)}-${await Yr(s,i)}`){case"false-false":return{mode:await i.mode(),path:o,oid:await i.oid(),type:await i.type()};case"false-true":return s?{mode:await s.mode(),path:o,oid:await s.oid(),type:await s.type()}:void 0;case"true-false":return r?{mode:await r.mode(),path:o,oid:await r.oid(),type:await r.type()}:void 0;case"true-true":if(r&&i&&s&&"blob"===await r.type()&&"blob"===await i.type()&&"blob"===await s.type())return async function({fs:t,gitdir:e,path:r,ours:i,base:a,theirs:n,ourName:s,theirName:o,baseName:c,dryRun:f,mergeDriver:d=oa}){const h="blob",u=await a.mode()===await i.mode()?await n.mode():await i.mode();if(await i.oid()===await n.oid())return{cleanMerge:!0,mergeResult:{mode:u,path:r,oid:await i.oid(),type:h}};if(await i.oid()===await a.oid())return{cleanMerge:!0,mergeResult:{mode:u,path:r,oid:await n.oid(),type:h}};if(await n.oid()===await a.oid())return{cleanMerge:!0,mergeResult:{mode:u,path:r,oid:await i.oid(),type:h}};const l=$.from(await i.content()).toString("utf8"),g=$.from(await a.content()).toString("utf8"),w=$.from(await n.content()).toString("utf8"),{mergedText:p,cleanMerge:m}=await d({branches:[c,s,o],contents:[g,l,w],path:r}),y=await Zr({fs:t,gitdir:e,type:"blob",object:$.from(p,"utf8"),dryRun:f});return{cleanMerge:m,mergeResult:{mode:u,path:r,oid:y,type:h}}}({fs:t,gitdir:a,path:o,ours:r,base:i,theirs:s,ourName:f,baseName:d,theirName:h,mergeDriver:g}).then((async t=>{if(t.cleanMerge)l||n.insert({filepath:e,oid:t.mergeResult.oid,stage:0});else if(y.push(e),b.push(e),!l){const t=await i.oid(),a=await r.oid(),o=await s.oid();n.delete({filepath:e}),n.insert({filepath:e,oid:t,stage:1}),n.insert({filepath:e,oid:a,stage:2}),n.insert({filepath:e,oid:o,stage:3})}return t.mergeResult}));if(i&&!r&&s&&"blob"===await i.type()&&"blob"===await s.type()){if(y.push(e),v.push(e),!l){const t=await i.oid(),r=await s.oid();n.delete({filepath:e}),n.insert({filepath:e,oid:t,stage:1}),n.insert({filepath:e,oid:r,stage:3})}return{mode:await s.mode(),oid:await s.oid(),type:"blob",path:o}}if(i&&r&&!s&&"blob"===await i.type()&&"blob"===await r.type()){if(y.push(e),x.push(e),!l){const t=await i.oid(),a=await r.oid();n.delete({filepath:e}),n.insert({filepath:e,oid:t,stage:1}),n.insert({filepath:e,oid:a,stage:2})}return{mode:await r.mode(),oid:await r.oid(),type:"blob",path:o}}if(i&&!r&&!s&&"blob"===await i.type())return;throw new or}},reduce:0===y.length||i&&!l?async(e,r)=>{const i=r.filter(Boolean);if(e&&(!e||"tree"!==e.type||0!==i.length)){if(i.length>0){const r=new Ue(i).toObject(),n=await Zr({fs:t,gitdir:a,type:"tree",object:r,dryRun:u});e.oid=n}return e}}:void 0});return 0!==y.length?(i&&!l&&await Dr({fs:t,cache:e,dir:i,gitdir:a,trees:[Ir({ref:E.oid})],map:async function(e,[r]){const a=`${i}/${e}`;if("blob"===await r.type()){const e=await r.mode(),i=(new TextDecoder).decode(await r.content());await t.write(a,i,{mode:e})}return!0}}),new cr(y,b,v,x)):E.oid}async function fa({fs:t,cache:e,dir:r,gitdir:i,ours:a,theirs:n,fastForward:s=!0,fastForwardOnly:o=!1,dryRun:c=!1,noUpdateBranch:f=!1,abortOnConflict:d=!0,message:h,author:u,committer:l,signingKey:g,onSign:w,mergeDriver:p}){void 0===a&&(a=await Ei({fs:t,gitdir:i,fullname:!0})),a=await je.expand({fs:t,gitdir:i,ref:a}),n=await je.expand({fs:t,gitdir:i,ref:n});const m=await je.resolve({fs:t,gitdir:i,ref:a}),y=await je.resolve({fs:t,gitdir:i,ref:n}),b=await na({fs:t,cache:e,gitdir:i,oids:[m,y]});if(1!==b.length)throw new or;const v=b[0];if(v===y)return{oid:m,alreadyMerged:!0};if(s&&v===m)return c||f||await je.writeRef({fs:t,gitdir:i,ref:a,value:y}),{oid:y,fastForward:!0};{if(o)throw new er;const s=await Zt.acquire({fs:t,gitdir:i,cache:e,allowUnmerged:!1},(async s=>ca({fs:t,cache:e,dir:r,gitdir:i,index:s,ourOid:m,theirOid:y,baseOid:v,ourName:xi(a),baseName:"base",theirName:xi(n),dryRun:c,abortOnConflict:d,mergeDriver:p})));if(s instanceof cr)throw s;h||(h=`Merge branch '${xi(n)}' into ${xi(a)}`);return{oid:await si({fs:t,cache:e,gitdir:i,message:h,ref:a,tree:s,parent:[m,y],author:u,committer:l,signingKey:g,onSign:w,dryRun:c,noUpdateBranch:f}),tree:s,mergeCommit:!0}}}async function da({fs:t,cache:e,http:r,onProgress:i,onMessage:a,onAuth:n,onAuthSuccess:s,onAuthFailure:o,dir:c,gitdir:f,ref:d,url:h,remote:u,remoteRef:l,prune:g,pruneTags:w,fastForward:p,fastForwardOnly:m,corsProxy:y,singleBranch:b,headers:v,author:x,committer:E,signingKey:_}){try{if(!d){const e=await Ei({fs:t,gitdir:f});if(!e)throw new dr("ref");d=e}const{fetchHead:$,fetchHeadDescription:S}=await qi({fs:t,cache:e,http:r,onProgress:i,onMessage:a,onAuth:n,onAuthSuccess:s,onAuthFailure:o,gitdir:f,corsProxy:y,ref:d,url:h,remote:u,remoteRef:l,singleBranch:b,headers:v,prune:g,pruneTags:w});await fa({fs:t,cache:e,gitdir:f,ours:d,theirs:$,fastForward:p,fastForwardOnly:m,message:`Merge ${S}`,author:x,committer:E,signingKey:_,dryRun:!1,noUpdateBranch:!1}),await yi({fs:t,cache:e,onProgress:i,dir:c,gitdir:f,ref:d,remote:u,noCheckout:!1})}catch(t){throw t.caller="git.pull",t}}async function ha({fs:t,http:e,onProgress:i,onMessage:a,onAuth:n,onAuthSuccess:s,onAuthFailure:o,dir:c,gitdir:f=r(c,".git"),ref:d,url:h,remote:u,remoteRef:l,corsProxy:g,singleBranch:w,headers:p={},cache:m={}}){try{Wr("fs",t),Wr("http",e),Wr("gitdir",f);const r={name:"",email:"",timestamp:Date.now(),timezoneOffset:0};return await da({fs:new zr(t),cache:m,http:e,onProgress:i,onMessage:a,onAuth:n,onAuthSuccess:s,onAuthFailure:o,dir:c,gitdir:f,ref:d,url:h,remote:u,remoteRef:l,fastForwardOnly:!0,corsProxy:g,singleBranch:w,headers:p,author:r,committer:r})}catch(t){throw t.caller="git.fastForward",t}}async function ua({fs:t,http:e,onProgress:i,onMessage:a,onAuth:n,onAuthSuccess:s,onAuthFailure:o,dir:c,gitdir:f=r(c,".git"),ref:d,remote:h,remoteRef:u,url:l,corsProxy:g,depth:w=null,since:p=null,exclude:m=[],relative:y=!1,tags:b=!1,singleBranch:v=!1,headers:x={},prune:E=!1,pruneTags:_=!1,cache:$={}}){try{return Wr("fs",t),Wr("http",e),Wr("gitdir",f),await qi({fs:new zr(t),cache:$,http:e,onProgress:i,onMessage:a,onAuth:n,onAuthSuccess:s,onAuthFailure:o,gitdir:f,ref:d,remote:h,remoteRef:u,url:l,corsProxy:g,depth:w,since:p,exclude:m,relative:y,tags:b,singleBranch:v,headers:x,prune:E,pruneTags:_})}catch(t){throw t.caller="git.fetch",t}}async function la({fs:t,dir:e,gitdir:i=r(e,".git"),oids:a,cache:n={}}){try{return Wr("fs",t),Wr("gitdir",i),Wr("oids",a),await na({fs:new zr(t),cache:n,gitdir:i,oids:a})}catch(t){throw t.caller="git.findMergeBase",t}}async function ga({fs:t,filepath:e}){if(await t.exists(r(e,".git")))return e;{const r=Xt(e);if(r===e)throw new ie(`git root for ${e}`);return ga({fs:t,filepath:r})}}async function wa({fs:t,filepath:e}){try{return Wr("fs",t),Wr("filepath",e),await ga({fs:new zr(t),filepath:e})}catch(t){throw t.caller="git.findRoot",t}}async function pa({fs:t,dir:e,gitdir:i=r(e,".git"),path:a}){try{return Wr("fs",t),Wr("gitdir",i),Wr("path",a),await ti({fs:new zr(t),gitdir:i,path:a})}catch(t){throw t.caller="git.getConfig",t}}async function ma({fs:t,dir:e,gitdir:i=r(e,".git"),path:a}){try{return Wr("fs",t),Wr("gitdir",i),Wr("path",a),await async function({fs:t,gitdir:e,path:r}){return(await Se.get({fs:t,gitdir:e})).getall(r)}({fs:new zr(t),gitdir:i,path:a})}catch(t){throw t.caller="git.getConfigAll",t}}async function ya({http:t,onAuth:e,onAuthSuccess:r,onAuthFailure:i,corsProxy:a,url:n,headers:s={},forPush:o=!1}){try{Wr("http",t),Wr("url",n);const c=Ci.getRemoteHelperFor({url:n}),f=await c.discover({http:t,onAuth:e,onAuthSuccess:r,onAuthFailure:i,corsProxy:a,service:o?"git-receive-pack":"git-upload-pack",url:n,headers:s,protocolVersion:1}),d={capabilities:[...f.capabilities]};for(const[t,e]of f.refs){const r=t.split("/"),i=r.pop();let a=d;for(const t of r)a[t]=a[t]||{},a=a[t];a[i]=e}for(const[t,e]of f.symrefs){const r=t.split("/"),i=r.pop();let a=d;for(const t of r)a[t]=a[t]||{},a=a[t];a[i]=e}return d}catch(t){throw t.caller="git.getRemoteInfo",t}}function ba(t,e,r,i){const a=[];for(const[n,s]of t.refs){if(e&&!n.startsWith(e))continue;if(n.endsWith("^{}")){if(i){const t=n.replace("^{}",""),e=a[a.length-1],r=e.ref===t?e:a.find((e=>e.ref===t));if(void 0===r)throw new Error("I did not expect this to happen");r.peeled=s}continue}const o={ref:n,oid:s};r&&t.symrefs.has(n)&&(o.target=t.symrefs.get(n)),a.push(o)}return a}async function va({http:t,onAuth:e,onAuthSuccess:r,onAuthFailure:i,corsProxy:a,url:n,headers:s={},forPush:o=!1,protocolVersion:c=2}){try{Wr("http",t),Wr("url",n);const f=Ci.getRemoteHelperFor({url:n}),d=await f.discover({http:t,onAuth:e,onAuthSuccess:r,onAuthFailure:i,corsProxy:a,service:o?"git-receive-pack":"git-upload-pack",url:n,headers:s,protocolVersion:c});if(2===d.protocolVersion)return{protocolVersion:d.protocolVersion,capabilities:d.capabilities2};const h={};for(const t of d.capabilities){const[e,r]=t.split("=");h[e]=r||!0}return{protocolVersion:1,capabilities:h,refs:ba(d,void 0,!0,!0)}}catch(t){throw t.caller="git.getRemoteInfo2",t}}async function xa({object:t}){try{Wr("object",t),t="string"==typeof t?$.from(t,"utf8"):$.from(t);const e="blob",{oid:r,object:i}=await async function({type:t,object:e,format:r="content",oid:i}){return"deflated"!==r&&("wrapped"!==r&&(e=Ce.wrap({type:t,object:e})),i=await Wt(e)),{oid:i,object:e}}({type:"blob",format:"content",object:t});return{oid:r,type:e,object:new Uint8Array(i),format:"wrapped"}}catch(t){throw t.caller="git.hashBlob",t}}async function Ea({fs:t,onProgress:e,dir:i,gitdir:a=r(i,".git"),filepath:n,cache:s={}}){try{return Wr("fs",t),Wr("dir",i),Wr("gitdir",i),Wr("filepath",n),await async function({fs:t,cache:e,onProgress:i,dir:a,gitdir:n,filepath:s}){try{s=r(a,s);const o=await t.read(s),c=r=>Ve({fs:t,cache:e,gitdir:n,oid:r}),f=await Ge.fromPack({pack:o,getExternalRefDelta:c,onProgress:i});return await t.write(s.replace(/\.pack$/,".idx"),await f.toBuffer()),{oids:[...f.hashes]}}catch(t){throw t.caller="git.indexPack",t}}({fs:new zr(t),cache:s,onProgress:e,dir:i,gitdir:a,filepath:n})}catch(t){throw t.caller="git.indexPack",t}}async function _a({fs:t,bare:e=!1,dir:i,gitdir:a=(e?i:r(i,".git")),defaultBranch:n="master"}){try{return Wr("fs",t),Wr("gitdir",a),e||Wr("dir",i),await Ki({fs:new zr(t),bare:e,dir:i,gitdir:a,defaultBranch:n})}catch(t){throw t.caller="git.init",t}}async function $a({fs:t,cache:e,gitdir:r,oid:i,ancestor:a,depth:n}){const s=await Mi.read({fs:t,gitdir:r});if(!i)throw new dr("oid");if(!a)throw new dr("ancestor");if(i===a)return!1;const o=[i],c=new Set;let f=0;for(;o.length;){if(f++===n)throw new sr(n);const i=o.shift(),{type:d,object:h}=await Ve({fs:t,cache:e,gitdir:r,oid:i});if("commit"!==d)throw new ae(i,d,"commit");const u=Rr.from(h).parse();for(const t of u.parent)if(t===a)return!0;if(!s.has(i))for(const t of u.parent)c.has(t)||(o.push(t),c.add(t))}return!1}async function Sa({fs:t,dir:e,gitdir:i=r(e,".git"),oid:a,ancestor:n,depth:s=-1,cache:o={}}){try{return Wr("fs",t),Wr("gitdir",i),Wr("oid",a),Wr("ancestor",n),await $a({fs:new zr(t),cache:o,gitdir:i,oid:a,ancestor:n,depth:s})}catch(t){throw t.caller="git.isDescendent",t}}async function Aa({fs:t,dir:e,gitdir:i=r(e,".git"),filepath:a}){try{return Wr("fs",t),Wr("dir",e),Wr("gitdir",i),Wr("filepath",a),qr.isIgnored({fs:new zr(t),dir:e,gitdir:i,filepath:a})}catch(t){throw t.caller="git.isIgnored",t}}async function Pa({fs:t,dir:e,gitdir:i=r(e,".git"),remote:a}){try{return Wr("fs",t),Wr("gitdir",i),je.listBranches({fs:new zr(t),gitdir:i,remote:a})}catch(t){throw t.caller="git.listBranches",t}}async function Ra({fs:t,gitdir:e,ref:r,cache:i}){if(r){const a=await je.resolve({gitdir:e,fs:t,ref:r}),n=[];return await ka({fs:t,cache:i,gitdir:e,oid:a,filenames:n,prefix:""}),n}return Zt.acquire({fs:t,gitdir:e,cache:i},(async function(t){return t.entries.map((t=>t.path))}))}async function ka({fs:t,cache:e,gitdir:i,oid:a,filenames:n,prefix:s}){const{tree:o}=await di({fs:t,cache:e,gitdir:i,oid:a});for(const a of o)"tree"===a.type?await ka({fs:t,cache:e,gitdir:i,oid:a.oid,filenames:n,prefix:r(s,a.path)}):n.push(r(s,a.path))}async function ja({fs:t,dir:e,gitdir:i=r(e,".git"),ref:a,cache:n={}}){try{return Wr("fs",t),Wr("gitdir",i),await Ra({fs:new zr(t),cache:n,gitdir:i,ref:a})}catch(t){throw t.caller="git.listFiles",t}}async function Ia({fs:t,dir:e,gitdir:i=r(e,".git"),ref:a="refs/notes/commits",cache:n={}}){try{return Wr("fs",t),Wr("gitdir",i),Wr("ref",a),await async function({fs:t,cache:e,gitdir:r,ref:i}){let a;try{a=await je.resolve({gitdir:r,fs:t,ref:i})}catch(t){if(t instanceof ie)return[]}return(await di({fs:t,cache:e,gitdir:r,oid:a})).tree.map((t=>({target:t.path,note:t.oid})))}({fs:new zr(t),cache:n,gitdir:i,ref:a})}catch(t){throw t.caller="git.listNotes",t}}async function Oa({fs:t,dir:e,gitdir:i=r(e,".git"),filepath:a}){try{return Wr("fs",t),Wr("gitdir",i),je.listRefs({fs:new zr(t),gitdir:i,filepath:a})}catch(t){throw t.caller="git.listRefs",t}}async function Ta({fs:t,dir:e,gitdir:i=r(e,".git")}){try{return Wr("fs",t),Wr("gitdir",i),await async function({fs:t,gitdir:e}){const r=await Se.get({fs:t,gitdir:e}),i=await r.getSubsections("remote");return Promise.all(i.map((async t=>({remote:t,url:await r.get(`remote.${t}.url`)}))))}({fs:new zr(t),gitdir:i})}catch(t){throw t.caller="git.listRemotes",t}}async function Ba({http:t,onAuth:e,onAuthSuccess:r,onAuthFailure:i,corsProxy:a,url:n,headers:s={},forPush:o=!1,protocolVersion:c=2,prefix:f,symrefs:d,peelTags:h}){try{Wr("http",t),Wr("url",n);const u=await Ui.discover({http:t,onAuth:e,onAuthSuccess:r,onAuthFailure:i,corsProxy:a,service:o?"git-receive-pack":"git-upload-pack",url:n,headers:s,protocolVersion:c});if(1===u.protocolVersion)return ba(u,f,d,h);const l=await async function({prefix:t,symrefs:e,peelTags:r}){const i=[];return i.push(Ri.encode("command=ls-refs\n")),i.push(Ri.encode(`agent=${Li}\n`)),(r||e||t)&&i.push(Ri.delim()),r&&i.push(Ri.encode("peel")),e&&i.push(Ri.encode("symrefs")),t&&i.push(Ri.encode(`ref-prefix ${t}`)),i.push(Ri.flush()),i}({prefix:f,symrefs:d,peelTags:h});return async function(t){const e=Ri.streamReader(t),r=[];let i;for(;i=await e(),!0!==i;){if(null===i)continue;i=i.toString("utf8").replace(/\n$/,"");const[t,e,...a]=i.split(" "),n={ref:e,oid:t};for(const t of a){const[e,r]=t.split(":");"symref-target"===e?n.target=r:"peeled"===e&&(n.peeled=r)}r.push(n)}return r}((await Ui.connect({http:t,auth:u.auth,headers:s,corsProxy:a,service:o?"git-receive-pack":"git-upload-pack",url:n,body:l})).body)}catch(t){throw t.caller="git.listServerRefs",t}}async function Ua({fs:t,dir:e,gitdir:i=r(e,".git")}){try{return Wr("fs",t),Wr("gitdir",i),je.listTags({fs:new zr(t),gitdir:i})}catch(t){throw t.caller="git.listTags",t}}function Ca(t,e){return t.committer.timestamp-e.committer.timestamp}async function Da({fs:t,cache:e,gitdir:r,oid:i,fileId:a}){if("e69de29bb2d1d6434b8b29ae775ad8c2e48c5391"===a)return;const n=i;let s;const o=await kr({fs:t,cache:e,gitdir:r,oid:i}),c=o.tree;return a===o.oid?s=o.path:(s=await Ma({fs:t,cache:e,gitdir:r,tree:c,fileId:a,oid:n}),Array.isArray(s)&&(0===s.length?s=void 0:1===s.length&&(s=s[0]))),s}async function Ma({fs:t,cache:e,gitdir:i,tree:a,fileId:n,oid:s,filepaths:o=[],parentPath:c=""}){const f=a.entries().map((function(a){let f;return a.oid===n?(f=r(c,a.path),o.push(f)):"tree"===a.type&&(f=Ve({fs:t,cache:e,gitdir:i,oid:a.oid}).then((function({object:f}){return Ma({fs:t,cache:e,gitdir:i,tree:Ue.from(f),fileId:n,oid:s,filepaths:o,parentPath:r(c,a.path)})}))),f}));return await Promise.all(f),o}async function Na({fs:t,dir:e,gitdir:i=r(e,".git"),filepath:a,ref:n="HEAD",depth:s,since:o,force:c,follow:f,cache:d={}}){try{return Wr("fs",t),Wr("gitdir",i),Wr("ref",n),await async function({fs:t,cache:e,gitdir:r,filepath:i,ref:a,depth:n,since:s,force:o,follow:c}){const f=void 0===s?void 0:Math.floor(s.valueOf()/1e3),d=[],h=await Mi.read({fs:t,gitdir:r}),u=await je.resolve({fs:t,gitdir:r,ref:a}),l=[await ni({fs:t,cache:e,gitdir:r,oid:u})];let g,w,p;function m(t){p&&i&&d.push(t)}for(;l.length>0;){const a=l.pop();if(void 0!==f&&a.commit.committer.timestamp<=f)break;if(i){let n;try{n=await ci({fs:t,cache:e,gitdir:r,oid:a.commit.tree,filepath:i}),w&&g!==n&&d.push(w),g=n,w=a,p=!0}catch(n){if(!(n instanceof ie))throw n;{let s=c&&g;if(s&&(s=await Da({fs:t,cache:e,gitdir:r,oid:a.commit.tree,fileId:g}),s))if(Array.isArray(s)){if(w){const a=await Da({fs:t,cache:e,gitdir:r,oid:w.commit.tree,fileId:g});if(Array.isArray(a)){if(s=s.filter((t=>-1===a.indexOf(t))),1!==s.length){s=!1,w&&d.push(w);break}s=s[0],i=s,w&&d.push(w)}}}else i=s,w&&d.push(w);if(!s){if(p&&g&&(d.push(w),!o))break;if(!o&&!c)throw n}w=a,p=!1}}}else d.push(a);if(void 0!==n&&d.length===n){m(a);break}if(!h.has(a.oid))for(const i of a.commit.parent){const a=await ni({fs:t,cache:e,gitdir:r,oid:i});l.map((t=>t.oid)).includes(a.oid)||l.push(a)}0===l.length&&m(a),l.sort(((t,e)=>Ca(t.commit,e.commit)))}return d}({fs:new zr(t),cache:d,gitdir:i,filepath:a,ref:n,depth:s,since:o,force:c,follow:f})}catch(t){throw t.caller="git.log",t}}async function Fa({fs:t,onSign:e,dir:i,gitdir:a=r(i,".git"),ours:n,theirs:s,fastForward:o=!0,fastForwardOnly:c=!1,dryRun:f=!1,noUpdateBranch:d=!1,abortOnConflict:h=!0,message:u,author:l,committer:g,signingKey:w,cache:p={},mergeDriver:m}){try{Wr("fs",t),w&&Wr("onSign",e);const r=new zr(t),y=await ri({fs:r,gitdir:a,author:l});if(!(y||c&&o))throw new fr("author");const b=await ii({fs:r,gitdir:a,author:y,committer:g});if(!(b||c&&o))throw new fr("committer");return await fa({fs:r,cache:p,dir:i,gitdir:a,ours:n,theirs:s,fastForward:o,fastForwardOnly:c,dryRun:f,noUpdateBranch:d,abortOnConflict:h,message:u,author:y,committer:b,signingKey:w,onSign:e,mergeDriver:m})}catch(t){throw t.caller="git.merge",t}}const Ha={commit:16,tree:32,blob:48,tag:64,ofs_delta:96,ref_delta:112};async function La({fs:t,cache:i,dir:a,gitdir:n=r(a,".git"),oids:s}){const o=new e,c=[];function f(t,e){const r=$.from(t,e);c.push(r),o.update(r)}async function d({stype:t,object:e}){const r=Ha[t];let i=e.length,a=i>15?128:0;const n=15&i;i>>>=4;let s=(a|r|n).toString(16);for(f(s,"hex");a;)a=i>127?128:0,s=a|127&i,f(Pi(2,s),"hex"),i>>>=7;f($.from(await Vr(e)))}f("PACK"),f("00000002","hex"),f(Pi(8,s.length),"hex");for(const e of s){const{type:r,object:a}=await Ve({fs:t,cache:i,gitdir:n,oid:e});await d({write:f,object:a,stype:r})}const h=o.digest();return c.push(h),c}async function za({fs:t,dir:e,gitdir:i=r(e,".git"),oids:a,write:n=!1,cache:s={}}){try{return Wr("fs",t),Wr("gitdir",i),Wr("oids",a),await async function({fs:t,cache:e,gitdir:i,oids:a,write:n}){const s=await La({fs:t,cache:e,gitdir:i,oids:a}),o=$.from(await Si(s)),c=`pack-${o.slice(-20).toString("hex")}.pack`;return n?(await t.write(r(i,`objects/pack/${c}`),o),{filename:c}):{filename:c,packfile:new Uint8Array(o)}}({fs:new zr(t),cache:s,gitdir:i,oids:a,write:n})}catch(t){throw t.caller="git.packObjects",t}}async function Wa({fs:t,http:e,onProgress:i,onMessage:a,onAuth:n,onAuthSuccess:s,onAuthFailure:o,dir:c,gitdir:f=r(c,".git"),ref:d,url:h,remote:u,remoteRef:l,prune:g=!1,pruneTags:w=!1,fastForward:p=!0,fastForwardOnly:m=!1,corsProxy:y,singleBranch:b,headers:v={},author:x,committer:E,signingKey:_,cache:$={}}){try{Wr("fs",t),Wr("gitdir",f);const r=new zr(t),S=await ri({fs:r,gitdir:f,author:x});if(!S)throw new fr("author");const A=await ii({fs:r,gitdir:f,author:S,committer:E});if(!A)throw new fr("committer");return await da({fs:r,cache:$,http:e,onProgress:i,onMessage:a,onAuth:n,onAuthSuccess:s,onAuthFailure:o,dir:c,gitdir:f,ref:d,url:h,remote:u,remoteRef:l,fastForward:p,fastForwardOnly:m,corsProxy:y,singleBranch:b,headers:v,author:S,committer:A,signingKey:_,prune:g,pruneTags:w})}catch(t){throw t.caller="git.pull",t}}async function Ya({fs:t,cache:e,dir:i,gitdir:a=r(i,".git"),oids:n}){const s=new Set;async function o(r){if(s.has(r))return;s.add(r);const{type:i,object:n}=await Ve({fs:t,cache:e,gitdir:a,oid:r});if("tag"===i){const t=Ar.from(n).headers().object;await o(t)}else if("commit"===i){const t=Rr.from(n).headers().tree;await o(t)}else if("tree"===i){const t=Ue.from(n);for(const e of t)"blob"===e.type&&s.add(e.oid),"tree"===e.type&&await o(e.oid)}}for(const t of n)await o(t);return s}async function Ga({fs:t,cache:e,http:i,onProgress:a,onMessage:n,onAuth:s,onAuthSuccess:o,onAuthFailure:c,onPrePush:f,gitdir:d,ref:h,remoteRef:u,remote:l,url:g,force:w=!1,delete:p=!1,corsProxy:m,headers:y={}}){const b=h||await Ei({fs:t,gitdir:d});if(void 0===b)throw new dr("ref");const v=await Se.get({fs:t,gitdir:d});l=l||await v.get(`branch.${b}.pushRemote`)||await v.get("remote.pushDefault")||await v.get(`branch.${b}.remote`)||"origin";const x=g||await v.get(`remote.${l}.pushurl`)||await v.get(`remote.${l}.url`);if(void 0===x)throw new dr("remote OR url");const E=u||await v.get(`branch.${b}.merge`);if(void 0===x)throw new dr("remoteRef");void 0===m&&(m=await v.get("http.corsProxy"));const _=await je.expand({fs:t,gitdir:d,ref:b}),$=p?"0000000000000000000000000000000000000000":await je.resolve({fs:t,gitdir:d,ref:_}),S=Ci.getRemoteHelperFor({url:x}),A=await S.discover({http:i,onAuth:s,onAuthSuccess:o,onAuthFailure:c,corsProxy:m,service:"git-receive-pack",url:x,headers:y,protocolVersion:1}),P=A.auth;let R;if(E)try{R=await je.expandAgainstMap({ref:E,map:A.refs})}catch(t){if(!(t instanceof ie))throw t;R=E.startsWith("refs/")?E:`refs/heads/${E}`}else R=_;const k=A.refs.get(R)||"0000000000000000000000000000000000000000";if(f){if(!await f({remote:l,url:x,localRef:{ref:p?"(delete)":_,oid:$},remoteRef:{ref:R,oid:k}}))throw new yr}const j=!A.capabilities.has("no-thin");let I=new Set;if(!p){const i=[...A.refs.values()];let a=new Set;if("0000000000000000000000000000000000000000"!==k){const r=await na({fs:t,cache:e,gitdir:d,oids:[$,k]});for(const t of r)i.push(t);j&&(a=await Ya({fs:t,cache:e,gitdir:d,oids:r}))}if(!i.includes($)){const a=await async function({fs:t,cache:e,dir:i,gitdir:a=r(i,".git"),start:n,finish:s}){const o=await Mi.read({fs:t,gitdir:a}),c=new Set,f=new Set;for(const e of n)c.add(await je.resolve({fs:t,gitdir:a,ref:e}));for(const e of s)try{const r=await je.resolve({fs:t,gitdir:a,ref:e});f.add(r)}catch(t){}const d=new Set;async function h(r){d.add(r);const{type:i,object:n}=await Ve({fs:t,cache:e,gitdir:a,oid:r});if("tag"===i)return h(Ar.from(n).headers().object);if("commit"!==i)throw new ae(r,i,"commit");if(!o.has(r)){const t=Rr.from(n).headers().parent;for(r of t)f.has(r)||d.has(r)||await h(r)}}for(const t of c)await h(t);return d}({fs:t,cache:e,gitdir:d,start:[$],finish:i});I=await Ya({fs:t,cache:e,gitdir:d,oids:a})}if(j){try{const r=await je.resolve({fs:t,gitdir:d,ref:`refs/remotes/${l}/HEAD`,depth:2}),{oid:i}=await je.resolveAgainstMap({ref:r.replace(`refs/remotes/${l}/`,""),fullref:r,map:A.refs}),n=[i];for(const r of await Ya({fs:t,cache:e,gitdir:d,oids:n}))a.add(r)}catch(t){}for(const t of a)I.delete(t)}if($===k&&(w=!0),!w){if(_.startsWith("refs/tags")&&"0000000000000000000000000000000000000000"!==k)throw new lr("tag-exists");if("0000000000000000000000000000000000000000"!==$&&"0000000000000000000000000000000000000000"!==k&&!await $a({fs:t,cache:e,gitdir:d,oid:$,ancestor:k,depth:-1}))throw new lr("not-fast-forward")}}const O=Fi([...A.capabilities],["report-status","side-band-64k",`agent=${Li}`]),T=await async function({capabilities:t=[],triplets:e=[]}){const r=[];let i=`\0 ${t.join(" ")}`;for(const t of e)r.push(Ri.encode(`${t.oldoid} ${t.oid} ${t.fullRef}${i}\n`)),i="";return r.push(Ri.flush()),r}({capabilities:O,triplets:[{oldoid:k,oid:$,fullRef:R}]}),B=p?[]:await La({fs:t,cache:e,gitdir:d,oids:[...I]}),U=await S.connect({http:i,onProgress:a,corsProxy:m,service:"git-receive-pack",url:x,auth:P,headers:y,body:[...T,...B]}),{packfile:C,progress:D}=await Gi.demux(U.body);if(n){$i(Yi(D),(async t=>{await n(t)}))}const M=await async function(t){const e={};let r="";const i=Ri.streamReader(t);let a=await i();for(;!0!==a;)null!==a&&(r+=a.toString("utf8")+"\n"),a=await i();const n=r.toString("utf8").split("\n");if(a=n.shift(),!a.startsWith("unpack "))throw new ur('unpack ok" or "unpack [error message]',a);e.ok="unpack ok"===a,e.ok||(e.error=a.slice(7)),e.refs={};for(const t of n){if(""===t.trim())continue;const r=t.slice(0,2),i=t.slice(3);let a=i.indexOf(" ");-1===a&&(a=i.length);const n=i.slice(0,a),s=i.slice(a+1);e.refs[n]={ok:"ok"===r,error:s}}return e}(C);if(U.headers&&(M.headers=U.headers),l&&M.ok&&M.refs[R].ok&&!_.startsWith("refs/tags")){const e=`refs/remotes/${l}/${R.replace("refs/heads","")}`;p?await je.deleteRef({fs:t,gitdir:d,ref:e}):await je.writeRef({fs:t,gitdir:d,ref:e,value:$})}if(M.ok&&Object.values(M.refs).every((t=>t.ok)))return M;{const t=Object.entries(M.refs).filter((([t,e])=>!e.ok)).map((([t,e])=>`\n  - ${t}: ${e.error}`)).join("");throw new rr(t,M)}}async function qa({fs:t,http:e,onProgress:i,onMessage:a,onAuth:n,onAuthSuccess:s,onAuthFailure:o,onPrePush:c,dir:f,gitdir:d=r(f,".git"),ref:h,remoteRef:u,remote:l="origin",url:g,force:w=!1,delete:p=!1,corsProxy:m,headers:y={},cache:b={}}){try{return Wr("fs",t),Wr("http",e),Wr("gitdir",d),await Ga({fs:new zr(t),cache:b,http:e,onProgress:i,onMessage:a,onAuth:n,onAuthSuccess:s,onAuthFailure:o,onPrePush:c,gitdir:d,ref:h,remoteRef:u,remote:l,url:g,force:w,delete:p,corsProxy:m,headers:y})}catch(t){throw t.caller="git.push",t}}async function Ka({fs:t,cache:e,gitdir:r,oid:i}){const{type:a,object:n}=await Ve({fs:t,cache:e,gitdir:r,oid:i});if("tag"===a)return Ka({fs:t,cache:e,gitdir:r,oid:i=Ar.from(n).parse().object});if("blob"!==a)throw new ae(i,a,"blob");return{oid:i,blob:new Uint8Array(n)}}async function Va({fs:t,cache:e,gitdir:r,oid:i,filepath:a}){void 0!==a&&(i=await ci({fs:t,cache:e,gitdir:r,oid:i,filepath:a}));return await Ka({fs:t,cache:e,gitdir:r,oid:i})}async function Za({fs:t,dir:e,gitdir:i=r(e,".git"),oid:a,filepath:n,cache:s={}}){try{return Wr("fs",t),Wr("gitdir",i),Wr("oid",a),await Va({fs:new zr(t),cache:s,gitdir:i,oid:a,filepath:n})}catch(t){throw t.caller="git.readBlob",t}}async function Ja({fs:t,dir:e,gitdir:i=r(e,".git"),oid:a,cache:n={}}){try{return Wr("fs",t),Wr("gitdir",i),Wr("oid",a),await ni({fs:new zr(t),cache:n,gitdir:i,oid:a})}catch(t){throw t.caller="git.readCommit",t}}async function Xa({fs:t,dir:e,gitdir:i=r(e,".git"),ref:a="refs/notes/commits",oid:n,cache:s={}}){try{return Wr("fs",t),Wr("gitdir",i),Wr("ref",a),Wr("oid",n),await async function({fs:t,cache:e,gitdir:r,ref:i="refs/notes/commits",oid:a}){const n=await je.resolve({gitdir:r,fs:t,ref:i}),{blob:s}=await Va({fs:t,cache:e,gitdir:r,oid:n,filepath:a});return s}({fs:new zr(t),cache:s,gitdir:i,ref:a,oid:n})}catch(t){throw t.caller="git.readNote",t}}async function Qa({fs:t,dir:e,gitdir:i=r(e,".git"),oid:a,format:n="parsed",filepath:s,encoding:o,cache:c={}}){try{Wr("fs",t),Wr("gitdir",i),Wr("oid",a);const e=new zr(t);void 0!==s&&(a=await ci({fs:e,cache:c,gitdir:i,oid:a,filepath:s}));const r="parsed"===n?"content":n,f=await Ve({fs:e,cache:c,gitdir:i,oid:a,format:r});if(f.oid=a,"parsed"===n)switch(f.format="parsed",f.type){case"commit":f.object=Rr.from(f.object).parse();break;case"tree":f.object=Ue.from(f.object).entries();break;case"blob":o?f.object=f.object.toString(o):(f.object=new Uint8Array(f.object),f.format="content");break;case"tag":f.object=Ar.from(f.object).parse();break;default:throw new ae(f.oid,f.type,"blob|commit|tag|tree")}else"deflated"!==f.format&&"wrapped"!==f.format||(f.type=f.format);return f}catch(t){throw t.caller="git.readObject",t}}async function tn({fs:t,dir:e,gitdir:i=r(e,".git"),oid:a,cache:n={}}){try{return Wr("fs",t),Wr("gitdir",i),Wr("oid",a),await async function({fs:t,cache:e,gitdir:r,oid:i}){const{type:a,object:n}=await Ve({fs:t,cache:e,gitdir:r,oid:i,format:"content"});if("tag"!==a)throw new ae(i,a,"tag");const s=Ar.from(n);return{oid:i,tag:s.parse(),payload:s.payload()}}({fs:new zr(t),cache:n,gitdir:i,oid:a})}catch(t){throw t.caller="git.readTag",t}}async function en({fs:t,dir:e,gitdir:i=r(e,".git"),oid:a,filepath:n,cache:s={}}){try{return Wr("fs",t),Wr("gitdir",i),Wr("oid",a),await di({fs:new zr(t),cache:s,gitdir:i,oid:a,filepath:n})}catch(t){throw t.caller="git.readTree",t}}async function rn({fs:t,dir:e,gitdir:i=r(e,".git"),filepath:a,cache:n={}}){try{Wr("fs",t),Wr("gitdir",i),Wr("filepath",a),await Zt.acquire({fs:new zr(t),gitdir:i,cache:n},(async function(t){t.delete({filepath:a})}))}catch(t){throw t.caller="git.remove",t}}async function an({fs:t,onSign:e,dir:i,gitdir:a=r(i,".git"),ref:n="refs/notes/commits",oid:s,author:o,committer:c,signingKey:f,cache:d={}}){try{Wr("fs",t),Wr("gitdir",a),Wr("oid",s);const r=new zr(t),i=await ri({fs:r,gitdir:a,author:o});if(!i)throw new fr("author");const h=await ii({fs:r,gitdir:a,author:i,committer:c});if(!h)throw new fr("committer");return await async function({fs:t,cache:e,onSign:r,gitdir:i,ref:a="refs/notes/commits",oid:n,author:s,committer:o,signingKey:c}){let f;try{f=await je.resolve({gitdir:i,fs:t,ref:a})}catch(t){if(!(t instanceof ie))throw t}let d=(await di({fs:t,gitdir:i,oid:f||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;d=d.filter((t=>t.path!==n));const h=await hi({fs:t,gitdir:i,tree:d});return await si({fs:t,cache:e,onSign:r,gitdir:i,ref:a,tree:h,parent:f&&[f],message:"Note removed by 'isomorphic-git removeNote'\n",author:s,committer:o,signingKey:c})}({fs:r,cache:d,onSign:e,gitdir:a,ref:n,oid:s,author:i,committer:h,signingKey:f})}catch(t){throw t.caller="git.removeNote",t}}async function nn({fs:t,dir:e,gitdir:i=r(e,".git"),ref:a,oldref:n,checkout:s=!1}){try{return Wr("fs",t),Wr("gitdir",i),Wr("ref",a),Wr("oldref",n),await async function({fs:t,gitdir:e,oldref:r,ref:i,checkout:a=!1}){if(i!==o.clean(i))throw new nr(i,o.clean(i));if(r!==o.clean(r))throw new nr(r,o.clean(r));const n=`refs/heads/${r}`,s=`refs/heads/${i}`;if(await je.exists({fs:t,gitdir:e,ref:s}))throw new Ze("branch",i,!1);const c=await je.resolve({fs:t,gitdir:e,ref:n,depth:1});await je.writeRef({fs:t,gitdir:e,ref:s,value:c}),await je.deleteRef({fs:t,gitdir:e,ref:n});const f=await Ei({fs:t,gitdir:e,fullname:!0});(a||f===n)&&await je.writeSymbolicRef({fs:t,gitdir:e,ref:"HEAD",value:s})}({fs:new zr(t),gitdir:i,ref:a,oldref:n,checkout:s})}catch(t){throw t.caller="git.renameBranch",t}}async function sn({gitdir:t,type:e,object:r}){return Wt(Ce.wrap({type:e,object:r}))}async function on({fs:t,dir:e,gitdir:i=r(e,".git"),filepath:a,ref:n,cache:s={}}){try{Wr("fs",t),Wr("gitdir",i),Wr("filepath",a);const o=new zr(t);let c,f;try{c=await je.resolve({fs:o,gitdir:i,ref:n||"HEAD"})}catch(t){if(n)throw t}if(c)try{c=await ci({fs:o,cache:s,gitdir:i,oid:c,filepath:a})}catch(t){c=null}let d={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:0,uid:0,gid:0,size:0};const h=e&&await o.read(r(e,a));h&&(f=await sn({gitdir:i,type:"blob",object:h}),c===f&&(d=await o.lstat(r(e,a)))),await Zt.acquire({fs:o,gitdir:i,cache:s},(async function(t){t.delete({filepath:a}),c&&t.insert({filepath:a,stats:d,oid:c})}))}catch(t){throw t.caller="git.reset",t}}async function cn({fs:t,dir:e,gitdir:i=r(e,".git"),ref:a,depth:n}){try{Wr("fs",t),Wr("gitdir",i),Wr("ref",a);return await je.resolve({fs:new zr(t),gitdir:i,ref:a,depth:n})}catch(t){throw t.caller="git.resolveRef",t}}async function fn({fs:t,dir:e,gitdir:i=r(e,".git"),path:a,value:n,append:s=!1}){try{Wr("fs",t),Wr("gitdir",i),Wr("path",a);const e=new zr(t),r=await Se.get({fs:e,gitdir:i});s?await r.append(a,n):await r.set(a,n),await Se.save({fs:e,gitdir:i,config:r})}catch(t){throw t.caller="git.setConfig",t}}async function dn({fs:t,gitdir:e,commit:r}){const i=Rr.from(r).toObject();return await Zr({fs:t,gitdir:e,type:"commit",object:i,format:"content"})}class hn{static get timezoneOffsetForRefLogEntry(){const t=(new Date).getTimezoneOffset(),e=Math.abs(Math.floor(t/60)),r=Math.abs(t%60).toString().padStart(2,"0");return`${t>0?"-":"+"}${e.toString().padStart(2,"0")}${r}`}static createStashReflogEntry(t,e,r){const i=t.name.replace(/\s/g,""),a=Math.floor(Date.now()/1e3),n=hn.timezoneOffsetForRefLogEntry;return`0000000000000000000000000000000000000000 ${e} ${i} ${t.email} ${a} ${n}\t${r}\n`}static getStashReflogEntry(t,e=!1){return t.split("\n").filter((t=>t)).reverse().map(((t,r)=>e?`stash@{${r}}: ${t.split("\t")[1]}`:t))}}const un={stage:re,workdir:Tr};let ln;async function gn(e,r){return void 0===ln&&(ln=new t),ln.acquire(e,r)}async function wn({fs:t,dir:e,gitdir:i,entries:a}){return Promise.all(a.map((async function a(n){if("tree"===n.type){if(!n.oid){const e=await Promise.all(n.children.map(a));n.oid=await hi({fs:t,gitdir:i,tree:e}),n.mode=16384}}else"blob"===n.type&&(n.oid=await async function(t,e,i,a,n=null){const s=r(i,a),o=await t.lstat(s);if(!o)throw new ie(s);if(o.isDirectory())throw new Bt(`${s}: file expected, but found directory`);const c=n?await De({fs:t,gitdir:e,oid:n}):void 0;let f=c?n:void 0;return c||await gn({fs:t,gitdir:e,currentFilepath:s},(async()=>{const r=o.isSymbolicLink()?await t.readlink(s).then(Jr):await t.read(s);if(null===r)throw new ie(s);f=await Zr({fs:t,gitdir:e,type:"blob",object:r})})),f}(t,i,e,n.path,n.oid),n.mode=33188);return n.path=n.path.split("/").pop(),n})))}async function pn({fs:t,dir:e,gitdir:r,treePair:i}){const a="stage"===i[1],n=i.map((t=>"string"==typeof t?un[t]():t)),s=[],o=await Dr({fs:t,cache:{},dir:e,gitdir:r,trees:n,map:async(i,[a,n])=>{if("."!==i&&!await qr.isIgnored({fs:t,dir:e,gitdir:r,filepath:i}))return n?((!a||await a.oid()!==await n.oid()&&void 0!==await n.oid())&&s.push([a,n]),{mode:await n.mode(),path:i,oid:await n.oid(),type:await n.type()}):void 0},reduce:async(t,e)=>(e=e.filter(Boolean),t?(t.children=e,t):e.length>0?e:void 0),iterate:async(r,i)=>{const n=[];for(const r of i){const[i,o]=r;a?o&&(await t.exists(`${e}/${o.toString()}`)?n.push(r):s.push([null,o])):i&&(o?n.push(r):s.push([i,null]))}return n.length?Promise.all(n.map(r)):[]}});if(0===s.length||0===o.length)return null;const c=(await wn({fs:t,dir:e,gitdir:r,entries:o})).filter(Boolean).map((t=>({mode:t.mode,path:t.path,oid:t.oid,type:t.type})));return hi({fs:t,gitdir:r,tree:c})}async function mn({fs:t,dir:e,gitdir:i,stashCommit:a,parentCommit:n,wasStaged:s}){const o=[],c=[],f=await Dr({fs:t,cache:{},dir:e,gitdir:i,trees:[Ir({ref:n}),Ir({ref:a})],map:async(a,[n,f])=>{if("."===a||await qr.isIgnored({fs:t,dir:e,gitdir:i,filepath:a}))return;const d=f?await f.type():await n.type();if("tree"!==d&&"blob"!==d)return;if(!f&&n){const t="tree"===d?"rmdir":"rm";return"tree"===d&&o.push(a),"blob"===d&&s&&c.push({filepath:a,oid:await n.oid()}),{method:t,filepath:a}}const h=await f.oid();return n&&await n.oid()===h?void 0:"tree"===d?{method:"mkdir",filepath:a}:(s&&c.push({filepath:a,oid:h,stats:await t.lstat(r(e,a))}),{method:"write",filepath:a,oid:h})}});await gn({fs:t,gitdir:i,dirRemoved:o,ops:f},(async()=>{for(const a of f){const n=r(e,a.filepath);switch(a.method){case"rmdir":await t.rmdir(n);break;case"mkdir":await t.mkdir(n);break;case"rm":await t.rm(n);break;case"write":if(!o.some((t=>n.startsWith(t)))){const{object:e}=await Ve({fs:t,cache:{},gitdir:i,oid:a.oid});await t.exists(n)&&await t.rm(n),await t.write(n,e)}}}})),await Zt.acquire({fs:t,gitdir:i,cache:{}},(async t=>{c.forEach((({filepath:e,stats:r,oid:i})=>{t.insert({filepath:e,stats:r,oid:i})}))}))}class yn{constructor({fs:t,dir:e,gitdir:i=r(e,".git")}){Object.assign(this,{fs:t,dir:e,gitdir:i,_author:null})}static get refStash(){return"refs/stash"}static get refLogsStash(){return"logs/refs/stash"}get refStashPath(){return r(this.gitdir,yn.refStash)}get refLogsStashPath(){return r(this.gitdir,yn.refLogsStash)}async getAuthor(){if(!this._author&&(this._author=await ri({fs:this.fs,gitdir:this.gitdir,author:{}}),!this._author))throw new fr("author");return this._author}async getStashSHA(t,e){if(!await this.fs.exists(this.refStashPath))return null;return(e||await this.readStashReflogs({parsed:!1}))[t].split(" ")[1]}async writeStashCommit({message:t,tree:e,parent:r}){return dn({fs:this.fs,gitdir:this.gitdir,commit:{message:t,tree:e,parent:r,author:await this.getAuthor(),committer:await this.getAuthor()}})}async readStashCommit(t){const e=await this.readStashReflogs({parsed:!1});if(0!==t&&(t<0||t>e.length-1))throw new nr(`stash@${t}`,"number that is in range of [0, num of stash pushed]");const r=await this.getStashSHA(t,e);return r?ni({fs:this.fs,cache:{},gitdir:this.gitdir,oid:r}):{}}async writeStashRef(t){return je.writeRef({fs:this.fs,gitdir:this.gitdir,ref:yn.refStash,value:t})}async writeStashReflogEntry({stashCommit:t,message:e}){const r=await this.getAuthor(),i=hn.createStashReflogEntry(r,t,e),a=this.refLogsStashPath;await gn({filepath:a,entry:i},(async()=>{const t=await this.fs.exists(a)?await this.fs.read(a,"utf8"):"";await this.fs.write(a,t+i,"utf8")}))}async readStashReflogs({parsed:t=!1}){if(!await this.fs.exists(this.refLogsStashPath))return[];const e=(await this.fs.read(this.refLogsStashPath)).toString();return hn.getStashReflogEntry(e,t)}}async function bn({fs:t,dir:e,gitdir:r,message:i=""}){const a=new yn({fs:t,dir:e,gitdir:r});await a.getAuthor();const n=await Ei({fs:t,gitdir:r,fullname:!1}),s=await je.resolve({fs:t,gitdir:r,ref:"HEAD"}),o=(await Ja({fs:t,dir:e,gitdir:r,oid:s})).commit.message,c=[s];let f=null,d=Ir({ref:"HEAD"});const h=await pn({fs:t,dir:e,gitdir:r,treePair:[Ir({ref:"HEAD"}),"stage"]});if(h){const t=await a.writeStashCommit({message:`stash-Index: WIP on ${n} - ${(new Date).toISOString()}`,tree:h,parent:c});c.push(t),f=h,d=re()}const u=await pn({fs:t,dir:e,gitdir:r,treePair:[d,"workdir"]});if(u){const t=await a.writeStashCommit({message:`stash-WorkDir: WIP on ${n} - ${(new Date).toISOString()}`,tree:u,parent:[c[c.length-1]]});c.push(t),f=u}if(!f||!h&&!u)throw new ie("changes, nothing to stash");const l=(i.trim()||`WIP on ${n}`)+`: ${s.substring(0,7)} ${o}`,g=await a.writeStashCommit({message:l,tree:f,parent:c});return await a.writeStashRef(g),await a.writeStashReflogEntry({stashCommit:g,message:l}),await bi({fs:t,dir:e,gitdir:r,ref:n,track:!1,force:!0}),g}async function vn({fs:t,dir:e,gitdir:r,refIdx:i=0}){const a=new yn({fs:t,dir:e,gitdir:r}),n=await a.readStashCommit(i),{parent:s=null}=n.commit?n.commit:{};if(s&&Array.isArray(s))for(let i=0;i<s.length-1;i++){const a=(await ni({fs:t,cache:{},gitdir:r,oid:s[i+1]})).commit.message.startsWith("stash-Index");await mn({fs:t,dir:e,gitdir:r,stashCommit:s[i+1],parentCommit:s[i],wasStaged:a})}}async function xn({fs:t,dir:e,gitdir:r,refIdx:i=0}){const a=new yn({fs:t,dir:e,gitdir:r});if(!(await a.readStashCommit(i)).commit)return;const n=a.refStashPath;await gn(n,(async()=>{await t.exists(n)&&await t.rm(n)}));const s=await a.readStashReflogs({parsed:!1});if(!s.length)return;s.splice(i,1);const o=a.refLogsStashPath;await gn({reflogEntries:s,stashReflogPath:o,stashMgr:a},(async()=>{if(s.length){await t.write(o,s.join("\n"),"utf8");const e=s[s.length-1].split(" ")[1];await a.writeStashRef(e)}else await t.rm(o)}))}async function En({fs:t,dir:e,gitdir:r}){return new yn({fs:t,dir:e,gitdir:r}).readStashReflogs({parsed:!0})}async function _n({fs:t,dir:e,gitdir:r}){const i=new yn({fs:t,dir:e,gitdir:r}),a=[i.refStashPath,i.refLogsStashPath];await gn(a,(async()=>{await Promise.all(a.map((async e=>{if(await t.exists(e))return t.rm(e)})))}))}async function $n({fs:t,dir:e,gitdir:r,refIdx:i=0}){await vn({fs:t,dir:e,gitdir:r,refIdx:i}),await xn({fs:t,dir:e,gitdir:r,refIdx:i})}async function Sn({fs:t,dir:e,gitdir:i=r(e,".git"),op:a="push",message:n="",refIdx:s=0}){Wr("fs",t),Wr("dir",e),Wr("gitdir",i),Wr("op",a);const o={push:bn,apply:vn,drop:xn,list:En,clear:_n,pop:$n},c=["apply","drop","pop"];try{const f=new zr(t);["refs","logs","logs/refs"].map((t=>r(i,t))).forEach((async t=>{await f.exists(t)||await f.mkdir(t)}));const d=o[a];if(d){if(c.includes(a)&&s<0)throw new nr(`stash@${s}`,"number that is in range of [0, num of stash pushed]");return await d({fs:f,dir:e,gitdir:i,message:n,refIdx:s})}throw new Error(`To be implemented: ${a}`)}catch(t){throw t.caller="git.stash",t}}async function An({fs:t,dir:e,gitdir:i=r(e,".git"),filepath:a,cache:n={}}){try{Wr("fs",t),Wr("gitdir",i),Wr("filepath",a);const s=new zr(t);if(await qr.isIgnored({fs:s,gitdir:i,dir:e,filepath:a}))return"ignored";const o=await async function({fs:t,cache:e,gitdir:r}){let i;try{i=await je.resolve({fs:t,gitdir:r,ref:"HEAD"})}catch(t){if(t instanceof ie)return[]}const{tree:a}=await di({fs:t,cache:e,gitdir:r,oid:i});return a}({fs:s,cache:n,gitdir:i}),c=await Pn({fs:s,cache:n,gitdir:i,tree:o,path:a}),f=await Zt.acquire({fs:s,gitdir:i,cache:n},(async function(t){for(const e of t)if(e.path===a)return e;return null})),d=await s.lstat(r(e,a)),h=null!==c,u=null!==f,l=null!==d,g=async()=>{if(u&&!qt(f,d))return f.oid;{const t=await s.read(r(e,a)),o=await sn({gitdir:i,type:"blob",object:t});return u&&f.oid===o&&-1!==d.size&&Zt.acquire({fs:s,gitdir:i,cache:n},(async function(t){t.insert({filepath:a,stats:d,oid:o})})),o}};if(!h&&!l&&!u)return"absent";if(!h&&!l&&u)return"*absent";if(!h&&l&&!u)return"*added";if(!h&&l&&u){return await g()===f.oid?"added":"*added"}if(h&&!l&&!u)return"deleted";if(h&&!l&&u)return f.oid,"*deleted";if(h&&l&&!u){return await g()===c?"*undeleted":"*undeletemodified"}if(h&&l&&u){const t=await g();return t===c?t===f.oid?"unmodified":"*unmodified":t===f.oid?"modified":"*modified"}}catch(t){throw t.caller="git.status",t}}async function Pn({fs:t,cache:e,gitdir:r,tree:i,path:a}){"string"==typeof a&&(a=a.split("/"));const n=a.shift();for(const s of i)if(s.path===n){if(0===a.length)return s.oid;const{type:i,object:n}=await Ve({fs:t,cache:e,gitdir:r,oid:s.oid});if("tree"===i){return Pn({fs:t,cache:e,gitdir:r,tree:Ue.from(n),path:a})}if("blob"===i)throw new ae(s.oid,i,"blob",a.join("/"))}return null}async function Rn({fs:t,dir:e,gitdir:i=r(e,".git"),ref:a="HEAD",filepaths:n=["."],filter:s,cache:o={},ignored:c=!1}){try{Wr("fs",t),Wr("gitdir",i),Wr("ref",a);const r=new zr(t);return await Dr({fs:r,cache:o,dir:e,gitdir:i,trees:[Ir({ref:a}),Tr(),re()],map:async function(t,[i,a,o]){if(!i&&!o&&a&&!c){if(await qr.isIgnored({fs:r,dir:e,filepath:t}))return null}if(!n.some((e=>mi(t,e))))return null;if(s&&!s(t))return;const[f,d,h]=await Promise.all([i&&i.type(),a&&a.type(),o&&o.type()]),u=[f,d,h].includes("blob");if(("tree"===f||"special"===f)&&!u)return;if("commit"===f)return null;if(("tree"===d||"special"===d)&&!u)return;if("commit"===h)return null;if(("tree"===h||"special"===h)&&!u)return;const l="blob"===f?await i.oid():void 0,g="blob"===h?await o.oid():void 0;let w;"blob"!==f&&"blob"===d&&"blob"!==h?w="42":"blob"===d&&(w=await a.oid());const p=[void 0,l,w,g],m=p.map((t=>p.indexOf(t)));return m.shift(),[t,...m]}})}catch(t){throw t.caller="git.statusMatrix",t}}async function kn({fs:t,dir:e,gitdir:i=r(e,".git"),ref:a,object:n,force:s=!1}){try{Wr("fs",t),Wr("gitdir",i),Wr("ref",a);const e=new zr(t);if(void 0===a)throw new dr("ref");a=a.startsWith("refs/tags/")?a:`refs/tags/${a}`;const r=await je.resolve({fs:e,gitdir:i,ref:n||"HEAD"});if(!s&&await je.exists({fs:e,gitdir:i,ref:a}))throw new Ze("tag",a);await je.writeRef({fs:e,gitdir:i,ref:a,value:r})}catch(t){throw t.caller="git.tag",t}}async function jn({fs:t,dir:e,gitdir:i=r(e,".git"),cache:a={},filepath:n,oid:s,mode:o,add:c,remove:f,force:d}){try{Wr("fs",t),Wr("gitdir",i),Wr("filepath",n);const h=new zr(t);if(f)return await Zt.acquire({fs:h,gitdir:i,cache:a},(async function(t){if(!d){const t=await h.lstat(r(e,n));if(t){if(t.isDirectory())throw new ar("directory");return}}t.has({filepath:n})&&t.delete({filepath:n})}));let u;if(!s){if(u=await h.lstat(r(e,n)),!u)throw new ie(`file at "${n}" on disk and "remove" not set`);if(u.isDirectory())throw new ar("directory")}return await Zt.acquire({fs:h,gitdir:i,cache:a},(async function(t){if(!c&&!t.has({filepath:n}))throw new ie(`file at "${n}" in index and "add" not set`);let a;if(s)a={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:o,uid:0,gid:0,size:0};else{a=u;const t=a.isSymbolicLink()?await h.readlink(r(e,n)):await h.read(r(e,n));s=await Zr({fs:h,gitdir:i,type:"blob",format:"content",object:t})}return t.insert({filepath:n,oid:s,stats:a}),s}))}catch(t){throw t.caller="git.updateIndex",t}}function In(){try{return Hi}catch(t){throw t.caller="git.version",t}}async function On({fs:t,dir:e,gitdir:i=r(e,".git"),trees:a,map:n,reduce:s,iterate:o,cache:c={}}){try{return Wr("fs",t),Wr("gitdir",i),Wr("trees",a),await Dr({fs:new zr(t),cache:c,dir:e,gitdir:i,trees:a,map:n,reduce:s,iterate:o})}catch(t){throw t.caller="git.walk",t}}async function Tn({fs:t,dir:e,gitdir:i=r(e,".git"),blob:a}){try{return Wr("fs",t),Wr("gitdir",i),Wr("blob",a),await Zr({fs:new zr(t),gitdir:i,type:"blob",object:a,format:"content"})}catch(t){throw t.caller="git.writeBlob",t}}async function Bn({fs:t,dir:e,gitdir:i=r(e,".git"),commit:a}){try{return Wr("fs",t),Wr("gitdir",i),Wr("commit",a),await dn({fs:new zr(t),gitdir:i,commit:a})}catch(t){throw t.caller="git.writeCommit",t}}async function Un({fs:t,dir:e,gitdir:i=r(e,".git"),type:a,object:n,format:s="parsed",oid:o,encoding:c}){try{const e=new zr(t);if("parsed"===s){switch(a){case"commit":n=Rr.from(n).toObject();break;case"tree":n=Ue.from(n).toObject();break;case"blob":n=$.from(n,c);break;case"tag":n=Ar.from(n).toObject();break;default:throw new ae(o||"",a,"blob|commit|tag|tree")}s="content"}return o=await Zr({fs:e,gitdir:i,type:a,object:n,oid:o,format:s})}catch(t){throw t.caller="git.writeObject",t}}async function Cn({fs:t,dir:e,gitdir:i=r(e,".git"),ref:a,value:n,force:s=!1,symbolic:c=!1}){try{Wr("fs",t),Wr("gitdir",i),Wr("ref",a),Wr("value",n);const e=new zr(t);if(a!==o.clean(a))throw new nr(a,o.clean(a));if(!s&&await je.exists({fs:e,gitdir:i,ref:a}))throw new Ze("ref",a);c?await je.writeSymbolicRef({fs:e,gitdir:i,ref:a,value:n}):(n=await je.resolve({fs:e,gitdir:i,ref:n}),await je.writeRef({fs:e,gitdir:i,ref:a,value:n}))}catch(t){throw t.caller="git.writeRef",t}}async function Dn({fs:t,dir:e,gitdir:i=r(e,".git"),tag:a}){try{return Wr("fs",t),Wr("gitdir",i),Wr("tag",a),await async function({fs:t,gitdir:e,tag:r}){const i=Ar.from(r).toObject();return await Zr({fs:t,gitdir:e,type:"tag",object:i,format:"content"})}({fs:new zr(t),gitdir:i,tag:a})}catch(t){throw t.caller="git.writeTag",t}}async function Mn({fs:t,dir:e,gitdir:i=r(e,".git"),tree:a}){try{return Wr("fs",t),Wr("gitdir",i),Wr("tree",a),await hi({fs:new zr(t),gitdir:i,tree:a})}catch(t){throw t.caller="git.writeTree",t}}var Nn={Errors:xr,STAGE:re,TREE:Ir,WORKDIR:Tr,add:Xr,abortMerge:Gr,addNote:ui,addRemote:gi,annotatedTag:wi,branch:pi,checkout:bi,clone:Vi,commit:Zi,getConfig:pa,getConfigAll:ma,setConfig:fn,currentBranch:Ji,deleteBranch:Xi,deleteRef:Qi,deleteRemote:ta,deleteTag:ea,expandOid:ia,expandRef:aa,fastForward:ha,fetch:ua,findMergeBase:la,findRoot:wa,getRemoteInfo:ya,getRemoteInfo2:va,hashBlob:xa,indexPack:Ea,init:_a,isDescendent:Sa,isIgnored:Aa,listBranches:Pa,listFiles:ja,listNotes:Ia,listRefs:Oa,listRemotes:Ta,listServerRefs:Ba,listTags:Ua,log:Na,merge:Fa,packObjects:za,pull:Wa,push:qa,readBlob:Za,readCommit:Ja,readNote:Xa,readObject:Qa,readTag:tn,readTree:en,remove:rn,removeNote:an,renameBranch:nn,resetIndex:on,updateIndex:jn,resolveRef:cn,status:An,statusMatrix:Rn,tag:kn,version:In,walk:On,writeBlob:Tn,writeCommit:Bn,writeObject:Un,writeRef:Cn,writeTag:Dn,writeTree:Mn,stash:Sn};export{xr as Errors,re as STAGE,Ir as TREE,Tr as WORKDIR,Gr as abortMerge,Xr as add,ui as addNote,gi as addRemote,wi as annotatedTag,pi as branch,bi as checkout,Vi as clone,Zi as commit,Ji as currentBranch,Nn as default,Xi as deleteBranch,Qi as deleteRef,ta as deleteRemote,ea as deleteTag,ia as expandOid,aa as expandRef,ha as fastForward,ua as fetch,la as findMergeBase,wa as findRoot,pa as getConfig,ma as getConfigAll,ya as getRemoteInfo,va as getRemoteInfo2,xa as hashBlob,Ea as indexPack,_a as init,Sa as isDescendent,Aa as isIgnored,Pa as listBranches,ja as listFiles,Ia as listNotes,Oa as listRefs,Ta as listRemotes,Ba as listServerRefs,Ua as listTags,Na as log,Fa as merge,za as packObjects,Wa as pull,qa as push,Za as readBlob,Ja as readCommit,Xa as readNote,Qa as readObject,tn as readTag,en as readTree,rn as remove,an as removeNote,nn as renameBranch,on as resetIndex,cn as resolveRef,fn as setConfig,Sn as stash,An as status,Rn as statusMatrix,kn as tag,jn as updateIndex,In as version,On as walk,Tn as writeBlob,Bn as writeCommit,Un as writeObject,Cn as writeRef,Dn as writeTag,Mn as writeTree};
//# sourceMappingURL=/sm/54ef3fbb44ea045707e9081ad4c0c66d012d0cfedda60bf2836a7ef990ce0415.map