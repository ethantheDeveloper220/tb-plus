const E={INVALID:["seeking position failed.","InvalidStateError"],GONE:["A requested file or directory could not be found at the time an operation was processed.","NotFoundError"],MISMATCH:["The path supplied exists, but was not an entry of requested type.","TypeMismatchError"],MOD_ERR:["The object can not be modified in this way.","InvalidModificationError"],SYNTAX:l=>[`Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. ${l}`,"SyntaxError"]},g={DOMException:globalThis.DOMException},h=window.Filer.path.join,n=window.anura.fs.promises,N=window.Filer.Buffer,f=window.anura.fs,{DOMException:r}=g,{INVALID:T,GONE:w,MISMATCH:_,MOD_ERR:m,SYNTAX:p}=E;function b(l){return l&&typeof l=="object"&&typeof l.constructor=="function"&&(typeof l.stream=="function"||typeof l.arrayBuffer=="function")&&/^(Blob|File)$/.test(l[Symbol.toStringTag])}class O{constructor(t,a){this._fileHandle=t,this._size=a,this._position=0}async abort(){const t=this._fileHandle;await new Promise((a,e)=>{f.close(t,i=>{i?e():a()})})}async write(t){if(typeof t=="object"){if(t.type==="write"){if(Number.isInteger(t.position)&&t.position>=0&&(this._position=t.position),!("data"in t)){const e=this._fileHandle;throw await new Promise((i,s)=>{f.close(e,o=>{o?s():i()})}),new r(...p("write requires a data argument"))}t=t.data}else if(t.type==="seek")if(Number.isInteger(t.position)&&t.position>=0){if(this._size<t.position)throw new r(...T);this._position=t.position;return}else{const e=this._fileHandle;throw await new Promise((i,s)=>{f.close(e,o=>{o?s():i()})}),new r(...p("seek requires a position argument"))}else if(t.type==="truncate")if(Number.isInteger(t.size)&&t.size>=0){console.log("handle:"),console.log(this._fileHandle);const e=this._fileHandle;await new Promise((i,s)=>{f.ftruncate(e,t.size,o=>{o?s():i()})}),this._size=t.size,this._position>this._size&&(this._position=this._size);return}else{const e=this._fileHandle;throw await new Promise((i,s)=>{f.close(e,o=>{o?s():i()})}),new r(...p("truncate requires a size argument"))}}if(t instanceof ArrayBuffer)t=new Uint8Array(t);else if(typeof t=="string")t=N.from(t);else if(b(t)){for await(const e of t.stream()){const i=await new Promise((s,o)=>{f.write(this._fileHandle,Filer.Buffer.from(e),0,e.length,this._position,(y,u)=>{y?o(y):s(u)})});this._position+=i.bytesWritten,this._size+=i.bytesWritten}return}const a=await new Promise((e,i)=>{f.write(this._fileHandle,Filer.Buffer.from(t),0,t.length,this._position,(s,o)=>{s?i(s):e(o)})});this._position+=a.bytesWritten,this._size+=a.bytesWritten}async close(){const t=this._fileHandle;await new Promise((a,e)=>{f.close(t,i=>{i?e():a()})})}}class d{constructor(t,a){this._path=t,this.name=a,this.kind="file"}async getFile(){return await n.stat(this._path).catch(t=>{if(t.code==="ENOENT")throw new r(...w)}),new File([await n.readFile(this._path)],this.name)}async isSameEntry(t){return this._path===this._getPath.apply(t)}_getPath(){return this._path}async createWritable(t){const a=await n.open(this._path,t.keepExistingData?"r+":"w+").catch(i=>{throw i.code==="ENOENT"?new r(...w):i}),{size:e}=await n.stat(this._path);return new O(a,e)}}class c{_path="";constructor(t="",a=""){this.name=a,this.kind="directory",this._path=t}async isSameEntry(t){return this._path===t._path}async*entries(){const t=this._path,a=await n.readdir(t).catch(e=>{throw e.code==="ENOENT"?new r(...w):e});for(let e of a){const i=Filer.path.join(t,e),s=await n.lstat(i);s.isFile()?yield[e,new d(i,e)]:s.isDirectory()&&(yield[e,new c(i,e)])}}async getDirectoryHandle(t,a){const e=h(this._path,t),i=await n.lstat(e).catch(o=>{if(o.code!=="ENOENT")throw o}),s=i?.isDirectory();if(i&&s)return new c(e,t);if(i&&!s)throw new r(..._);if(!a.create)throw new r(...w);return await n.mkdir(e),new c(e,t)}async getFileHandle(t,a){const e=h(this._path,t),i=await n.lstat(e).catch(o=>{if(o.code!=="ENOENT")throw o}),s=i?.isFile();if(i&&s)return new d(e,t);if(i&&!s)throw new r(..._);if(!a.create)throw new r(...w);return anura.fs.close(await n.open(e,"w")),new d(e,t)}async queryPermission(){return"granted"}async removeEntry(t,a){const e=h(this._path,t);(await n.lstat(e).catch(s=>{throw s.code==="ENOENT"?new r(...w):s})).isDirectory()?a.recursive?await n.rm(e,{recursive:!0}).catch(s=>{throw s.code==="ENOTEMPTY"?new r(...m):s}):await n.rmdir(e).catch(s=>{throw s.code==="ENOTEMPTY"?new r(...m):s}):await n.unlink(e)}}const F=l=>new c("/");export{d as FileHandle,c as FolderHandle,O as Sink,F as default};
