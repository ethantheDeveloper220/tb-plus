const L=globalThis.showDirectoryPicker;async function fe(n={}){if(L&&!n._preferPolyfill)return L(n);const e=document.createElement("input");e.type="file",e.webkitdirectory=!0,e.multiple=!0,e.style.position="fixed",e.style.top="-100000px",e.style.left="-100000px",document.body.appendChild(e);const t=Promise.resolve().then((function(){return V}));return await new Promise((i=>{e.addEventListener("change",i),e.click()})),t.then((i=>i.getDirHandlesFromInput(e)))}const J={accepts:[]},W=globalThis.showOpenFilePicker;async function pe(n={}){const e={...J,...n};if(W&&!n._preferPolyfill)return W(e);const t=document.createElement("input");t.type="file",t.multiple=e.multiple,t.accept=(e.accepts||[]).map((r=>[...(r.extensions||[]).map((s=>"."+s)),...r.mimeTypes||[]])).flat().join(","),Object.assign(t.style,{position:"fixed",top:"-100000px",left:"-100000px"}),document.body.appendChild(t);const i=Promise.resolve().then((function(){return V}));return await new Promise((r=>{t.addEventListener("change",r,{once:!0}),t.click()})),t.remove(),i.then((r=>r.getFileHandlesFromInput(t)))}const U=globalThis.showSaveFilePicker;async function me(n={}){if(U&&!n._preferPolyfill)return U(n);n._name&&(console.warn("deprecated _name, spec now have `suggestedName`"),n.suggestedName=n._name);const{FileSystemFileHandle:e}=await Promise.resolve().then((function(){return v})),{FileHandle:t}=await Promise.resolve().then((function(){return le}));return new e(new t(n.suggestedName))}async function be(n,e={}){if(!n)return globalThis.navigator?.storage?.getDirectory()||globalThis.getOriginPrivateDirectory();const{FileSystemDirectoryHandle:t}=await Promise.resolve().then((function(){return T})),i=await n;return new t(await(i.default?i.default(e):i(e)))}globalThis.DataTransferItem&&!DataTransferItem.prototype.getAsFileSystemHandle&&(DataTransferItem.prototype.getAsFileSystemHandle=async function(){const n=this.webkitGetAsEntry(),[{FileHandle:e,FolderHandle:t},{FileSystemDirectoryHandle:i},{FileSystemFileHandle:r}]=await Promise.all([Promise.resolve().then((function(){return $})),Promise.resolve().then((function(){return T})),Promise.resolve().then((function(){return v}))]);return n.isFile?new r(new e(n,!1)):new i(new t(n,!1))});const j={WritableStream:globalThis.WritableStream,TransformStream:globalThis.TransformStream,DOMException:globalThis.DOMException,Blob:globalThis.Blob,File:globalThis.File},{WritableStream:K}=j;class F extends K{#e;constructor(e){super(e),this.#e=e,Object.setPrototypeOf(this,F.prototype),this._closed=!1}async close(){this._closed=!0;const e=this.getWriter(),t=e.close();return e.releaseLock(),t}seek(e){return this.write({type:"seek",position:e})}truncate(e){return this.write({type:"truncate",size:e})}write(e){if(this._closed)return Promise.reject(new TypeError("Cannot write to a CLOSED writable stream"));const t=this.getWriter(),i=t.write(e);return t.releaseLock(),i}}Object.defineProperty(F.prototype,Symbol.toStringTag,{value:"FileSystemWritableFileStream",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(F.prototype,{close:{enumerable:!0},seek:{enumerable:!0},truncate:{enumerable:!0},write:{enumerable:!0}}),!globalThis.FileSystemFileHandle||globalThis.FileSystemFileHandle.prototype.createWritable||globalThis.FileSystemWritableFileStream||(globalThis.FileSystemWritableFileStream=F);const p=Symbol("adapter");class A{[p];name;kind;constructor(e){this.kind=e.kind,this.name=e.name,this[p]=e}async queryPermission(e={}){const{mode:t="read"}=e,i=this[p];if(i.queryPermission)return i.queryPermission({mode:t});if(t==="read")return"granted";if(t==="readwrite")return i.writable?"granted":"denied";throw new TypeError(`Mode ${t} must be 'read' or 'readwrite'`)}async requestPermission({mode:e="read"}={}){const t=this[p];if(t.requestPermission)return t.requestPermission({mode:e});if(e==="read")return"granted";if(e==="readwrite")return t.writable?"granted":"denied";throw new TypeError(`Mode ${e} must be 'read' or 'readwrite'`)}async remove(e={}){await this[p].remove(e)}async isSameEntry(e){return this===e||!(!e||typeof e!="object"||this.kind!==e.kind||!e[p])&&this[p].isSameEntry(e[p])}}Object.defineProperty(A.prototype,Symbol.toStringTag,{value:"FileSystemHandle",writable:!1,enumerable:!1,configurable:!0}),globalThis.FileSystemHandle&&(globalThis.FileSystemHandle.prototype.queryPermission??=function(n){return"granted"});const E={INVALID:["seeking position failed.","InvalidStateError"],GONE:["A requested file or directory could not be found at the time an operation was processed.","NotFoundError"],MISMATCH:["The path supplied exists, but was not an entry of requested type.","TypeMismatchError"],MOD_ERR:["The object can not be modified in this way.","InvalidModificationError"],SYNTAX:n=>[`Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. ${n}`,"SyntaxError"],SECURITY:["It was determined that certain files are unsafe for access within a Web application, or that too many calls are being made on file resources.","SecurityError"],DISALLOWED:["The request is not allowed by the user agent or the platform in the current context.","NotAllowedError"]},Q={writable:globalThis.WritableStream};var V=Object.freeze({__proto__:null,errors:E,config:Q,fromDataTransfer:async function(n){console.warn("deprecated fromDataTransfer - use `dt.items[0].getAsFileSystemHandle()` instead");const[e,t,i]=await Promise.all([Promise.resolve().then((function(){return I})),Promise.resolve().then((function(){return $})),Promise.resolve().then((function(){return T}))]),r=new e.FolderHandle("",!1);return r._entries=n.map((s=>s.isFile?new t.FileHandle(s,!1):new t.FolderHandle(s,!1))),new i.FileSystemDirectoryHandle(r)},getDirHandlesFromInput:async function(n){const{FolderHandle:e,FileHandle:t}=await Promise.resolve().then((function(){return I})),{FileSystemDirectoryHandle:i}=await Promise.resolve().then((function(){return T})),r=Array.from(n.files),s=r[0].webkitRelativePath.split("/",1)[0],o=new e(s,!1);return r.forEach((c=>{const l=c.webkitRelativePath.split("/");l.shift();const h=l.pop();l.reduce(((u,w)=>(u._entries[w]||(u._entries[w]=new e(w,!1)),u._entries[w])),o)._entries[h]=new t(c.name,c,!1)})),new i(o)},getFileHandlesFromInput:async function(n){const{FileHandle:e}=await Promise.resolve().then((function(){return I})),{FileSystemFileHandle:t}=await Promise.resolve().then((function(){return v}));return Array.from(n.files).map((i=>new t(new e(i.name,i,!1))))}});const{GONE:Z,MOD_ERR:ee}=E,m=Symbol("adapter");class g extends A{[m];constructor(e){super(e),this[m]=e}async getDirectoryHandle(e,t={}){if(e==="")throw new TypeError("Name can't be an empty string.");if(e==="."||e===".."||e.includes("/"))throw new TypeError("Name contains invalid characters.");t.create=!!t.create;const i=await this[m].getDirectoryHandle(e,t);return new g(i)}async*entries(){const{FileSystemFileHandle:e}=await Promise.resolve().then((function(){return v}));for await(const[t,i]of this[m].entries())yield[i.name,i.kind==="file"?new e(i):new g(i)]}async*getEntries(){const{FileSystemFileHandle:e}=await Promise.resolve().then((function(){return v}));console.warn("deprecated, use .entries() instead");for await(let t of this[m].entries())yield t.kind==="file"?new e(t):new g(t)}async getFileHandle(e,t={}){const{FileSystemFileHandle:i}=await Promise.resolve().then((function(){return v}));if(e==="")throw new TypeError("Name can't be an empty string.");if(e==="."||e===".."||e.includes("/"))throw new TypeError("Name contains invalid characters.");return t.create=!!t.create,new i(await this[m].getFileHandle(e,t))}async removeEntry(e,t={}){if(e==="")throw new TypeError("Name can't be an empty string.");if(e==="."||e===".."||e.includes("/"))throw new TypeError("Name contains invalid characters.");return t.recursive=!!t.recursive,this[m].removeEntry(e,t)}async resolve(e){if(await e.isSameEntry(this))return[];const t=[{handle:this,path:[]}];for(;t.length;){let{handle:i,path:r}=t.pop();for await(const s of i.values()){if(await s.isSameEntry(e))return[...r,s.name];s.kind==="directory"&&t.push({handle:s,path:[...r,s.name]})}}return null}async*keys(){for await(const[e]of this[m].entries())yield e}async*values(){for await(const[e,t]of this)yield t}[Symbol.asyncIterator](){return this.entries()}}if(Object.defineProperty(g.prototype,Symbol.toStringTag,{value:"FileSystemDirectoryHandle",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(g.prototype,{getDirectoryHandle:{enumerable:!0},entries:{enumerable:!0},getFileHandle:{enumerable:!0},removeEntry:{enumerable:!0}}),globalThis.FileSystemDirectoryHandle){const n=globalThis.FileSystemDirectoryHandle.prototype;n.resolve=async function(i){if(await i.isSameEntry(this))return[];const r=[{handle:this,path:[]}];for(;r.length;){let{handle:s,path:o}=r.pop();for await(const c of s.values()){if(await c.isSameEntry(i))return[...o,c.name];c.kind==="directory"&&r.push({handle:c,path:[...o,c.name]})}}return null};const e=n.entries;n.entries=async function*(){await(async function(i){if(await(await navigator.storage.getDirectory()).resolve(i)===null)throw new DOMException(...Z)})(this),yield*e.call(this)},n[Symbol.asyncIterator]=async function*(){yield*this.entries()};const t=n.removeEntry;n.removeEntry=async function(i,r={}){return t.call(this,i,r).catch((async s=>{throw s instanceof DOMException&&s.name==="UnknownError"&&!r.recursive&&!(await e.call(this).next()).done?new DOMException(...ee):s}))}}var T=Object.freeze({__proto__:null,default:g,FileSystemDirectoryHandle:g});const{INVALID:te,SYNTAX:z,GONE:ie}=E,H=Symbol("adapter");class k extends A{[H];constructor(e){super(e),this[H]=e}async createWritable(e={}){return new F(await this[H].createWritable(e))}async getFile(){return this[H].getFile()}}if(Object.defineProperty(k.prototype,Symbol.toStringTag,{value:"FileSystemFileHandle",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(k.prototype,{createWritable:{enumerable:!0},getFile:{enumerable:!0}}),globalThis.FileSystemFileHandle&&!globalThis.FileSystemFileHandle.prototype.createWritable){const n=new WeakMap;let e;const t=()=>{let r,s;onmessage=async o=>{const c=o.ports[0],l=o.data;switch(l.type){case"open":const h=l.name;let u=await navigator.storage.getDirectory();for(const w of l.path)u=await u.getDirectoryHandle(w);r=await u.getFileHandle(h),s=await r.createSyncAccessHandle();break;case"write":s.write(l.data,{at:l.position}),s.flush();break;case"truncate":s.truncate(l.size);break;case"abort":case"close":s.close()}c.postMessage(0)}};globalThis.FileSystemFileHandle.prototype.createWritable=async function(r){if(!e){const a=`(${t.toString()})()`,y=new Blob([a],{type:"text/javascript"});e=URL.createObjectURL(y)}const s=new Worker(e,{type:"module"});let o=0;const c=new TextEncoder;let l=await this.getFile().then((a=>a.size));const h=a=>new Promise(((y,N)=>{const f=new MessageChannel;f.port1.onmessage=x=>{x.data instanceof Error?N(x.data):y(x.data),f.port1.close(),f.port2.close(),f.port1.onmessage=null},s.postMessage(a,[f.port2])})),u=await navigator.storage.getDirectory(),w=await n.get(this),P=await u.resolve(w);if(P===null)throw new DOMException(...ie);return await h({type:"open",path:P,name:this.name}),r?.keepExistingData===!1&&(await h({type:"truncate",size:0}),l=0),new F({start:a=>{},async write(a){if((a=a?.constructor===Object?{...a}:{type:"write",data:a,position:o}).type==="write"){if(!("data"in a))throw await h({type:"close"}),new DOMException(...z("write requires a data argument"));if(a.position??=o,typeof a.data=="string")a.data=c.encode(a.data);else if(a.data instanceof ArrayBuffer)a.data=new Uint8Array(a.data);else if(a.data instanceof Uint8Array||!ArrayBuffer.isView(a.data)){if(!(a.data instanceof Uint8Array)){const y=await new Response(a.data).arrayBuffer();a.data=new Uint8Array(y)}}else a.data=new Uint8Array(a.data.buffer,a.data.byteOffset,a.data.byteLength);Number.isInteger(a.position)&&a.position>=0&&(o=a.position),o+=a.data.byteLength,l+=a.data.byteLength}else{if(a.type==="seek"){if(Number.isInteger(a.position)&&a.position>=0){if(l<a.position)throw new DOMException(...te);return console.log("seeking",a),void(o=a.position)}throw await h({type:"close"}),new DOMException(...z("seek requires a position argument"))}if(a.type==="truncate"){if(!(Number.isInteger(a.size)&&a.size>=0))throw await h({type:"close"}),new DOMException(...z("truncate requires a size argument"));l=a.size,o>l&&(o=l)}}await h(a)},async close(){await h({type:"close"}),s.terminate()},async abort(a){await h({type:"abort",reason:a}),s.terminate()}})};const i=FileSystemDirectoryHandle.prototype.getFileHandle;FileSystemDirectoryHandle.prototype.getFileHandle=async function(...r){const s=await i.call(this,...r);return n.set(s,this),s}}var v=Object.freeze({__proto__:null,default:k,FileSystemFileHandle:k});const{WritableStream:q,TransformStream:B,DOMException:re,Blob:C}=j,{GONE:ne}=E,se=/constructor/i.test(window.HTMLElement);class ae{constructor(e){e.onmessage=t=>this._onMessage(t.data),this._port=e,this._resetReady()}start(e){return this._controller=e,this._readyPromise}write(e){const t={type:0,chunk:e};return this._port.postMessage(t,[e.buffer]),this._resetReady(),this._readyPromise}close(){this._port.postMessage({type:2}),this._port.close()}abort(e){this._port.postMessage({type:1,reason:e}),this._port.close()}_onMessage(e){e.type===0&&this._resolveReady(),e.type===1&&this._onError(e.reason)}_onError(e){this._controller.error(e),this._rejectReady(e),this._port.close()}_resetReady(){this._readyPromise=new Promise(((e,t)=>{this._readyResolve=e,this._readyReject=t})),this._readyPending=!0}_resolveReady(){this._readyResolve(),this._readyPending=!1}_rejectReady(e){this._readyPending||this._resetReady(),this._readyPromise.catch((()=>{})),this._readyReject(e),this._readyPending=!1}}class oe{constructor(e){const t=new MessageChannel;this.readablePort=t.port1,this.writable=new e(new ae(t.port2))}}var le=Object.freeze({__proto__:null,FileHandle:class{constructor(n="unkown"){this.name=n,this.kind="file"}async getFile(){throw new re(...ne)}async isSameEntry(n){return this===n}async createWritable(n={}){const e=await navigator.serviceWorker?.getRegistration(),t=document.createElement("a"),i=new B,r=i.writable;if(t.download=this.name,se||!e){let s=[];i.readable.pipeTo(new q({write(o){s.push(new C([o]))},close(){const o=new C(s,{type:"application/octet-stream; charset=utf-8"});s=[],t.href=URL.createObjectURL(o),t.click(),setTimeout((()=>URL.revokeObjectURL(t.href)),1e4)}}))}else{const{writable:s,readablePort:o}=new oe(q),c=encodeURIComponent(this.name).replace(/['()]/g,escape).replace(/\*/g,"%2A"),l={"content-disposition":"attachment; filename*=UTF-8''"+c,"content-type":"application/octet-stream; charset=utf-8",...n.size?{"content-length":n.size}:{}},h=setTimeout((()=>e.active.postMessage(0)),1e4);i.readable.pipeThrough(new B({transform(w,P){if(w instanceof Uint8Array)return P.enqueue(w);const a=new Response(w).body.getReader(),y=N=>a.read().then((f=>f.done?0:y(P.enqueue(f.value))));return y()}})).pipeTo(s).finally((()=>{clearInterval(h)})),e.active.postMessage({url:e.scope+c,headers:l,readablePort:o},[o]);const u=document.createElement("iframe");u.hidden=!0,u.src=e.scope+c,document.body.appendChild(u)}return r.getWriter()}}});const{DISALLOWED:ce}=E;class G{constructor(e,t){this.writer=e,this.fileEntry=t}async write(e){if(typeof e=="object")if(e.type==="write"){if(Number.isInteger(e.position)&&e.position>=0&&(this.writer.seek(e.position),this.writer.position!==e.position&&(await new Promise(((t,i)=>{this.writer.onwriteend=t,this.writer.onerror=i,this.writer.truncate(e.position)})),this.writer.seek(e.position))),!("data"in e))throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. write requires a data argument","SyntaxError");e=e.data}else{if(e.type==="seek"){if(Number.isInteger(e.position)&&e.position>=0){if(this.writer.seek(e.position),this.writer.position!==e.position)throw new DOMException("seeking position failed","InvalidStateError");return}throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. seek requires a position argument","SyntaxError")}if(e.type==="truncate")return new Promise((t=>{if(!(Number.isInteger(e.size)&&e.size>=0))throw new DOMException("Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. truncate requires a size argument","SyntaxError");this.writer.onwriteend=i=>t(),this.writer.truncate(e.size)}))}await new Promise(((t,i)=>{this.writer.onwriteend=t,this.writer.onerror=i,this.writer.write(new Blob([e]))}))}close(){return new Promise(this.fileEntry.file.bind(this.fileEntry))}}class R{constructor(e,t=!0){this.file=e,this.kind="file",this.writable=t,this.readable=!0}get name(){return this.file.name}isSameEntry(e){return this.file.toURL()===e.file.toURL()}getFile(){return new Promise(this.file.file.bind(this.file))}createWritable(e){if(!this.writable)throw new DOMException(...ce);return new Promise(((t,i)=>this.file.createWriter((r=>{e.keepExistingData===!1?(r.onwriteend=s=>t(new G(r,this.file)),r.truncate(0)):t(new G(r,this.file))}),i)))}}class _{constructor(e,t=!0){this.dir=e,this.writable=t,this.readable=!0,this.kind="directory",this.name=e.name}isSameEntry(e){return this.dir.fullPath===e.dir.fullPath}async*entries(){const e=this.dir.createReader(),t=await new Promise(e.readEntries.bind(e));for(const i of t)yield[i.name,i.isFile?new R(i,this.writable):new _(i,this.writable)]}getDirectoryHandle(e,t){return new Promise(((i,r)=>{this.dir.getDirectory(e,t,(s=>{i(new _(s))}),r)}))}getFileHandle(e,t){return new Promise(((i,r)=>this.dir.getFile(e,t,(s=>i(new R(s))),r)))}async removeEntry(e,t){const i=await this.getDirectoryHandle(e,{create:!1}).catch((r=>r.name==="TypeMismatchError"?this.getFileHandle(e,{create:!1}):r));if(i instanceof Error)throw i;return new Promise(((r,s)=>{i instanceof _?t.recursive?i.dir.removeRecursively((()=>r()),s):i.dir.remove((()=>r()),s):i.file&&i.file.remove((()=>r()),s)}))}}var $=Object.freeze({__proto__:null,FileHandle:R,FolderHandle:_,default:(n={})=>new Promise(((e,t)=>window.webkitRequestFileSystem(n._persistent,0,(i=>e(new _(i.root))),t)))});const{File:S,Blob:de,DOMException:d}=j,{INVALID:he,GONE:b,MISMATCH:Y,MOD_ERR:ue,SYNTAX:M,SECURITY:ge,DISALLOWED:we}=E;class X{constructor(e,t){this.fileHandle=e,this.file=t,this.size=t.size,this.position=0}write(e){let t=this.file;if(typeof e=="object")if(e.type==="write"){if(Number.isInteger(e.position)&&e.position>=0&&(this.position=e.position,this.size<e.position&&(this.file=new S([this.file,new ArrayBuffer(e.position-this.size)],this.file.name,this.file))),!("data"in e))throw new d(...M("write requires a data argument"));e=e.data}else{if(e.type==="seek"){if(Number.isInteger(e.position)&&e.position>=0){if(this.size<e.position)throw new d(...he);return void(this.position=e.position)}throw new d(...M("seek requires a position argument"))}if(e.type==="truncate"){if(Number.isInteger(e.size)&&e.size>=0)return t=e.size<this.size?new S([t.slice(0,e.size)],t.name,t):new S([t,new Uint8Array(e.size-this.size)],t.name),this.size=t.size,this.position>t.size&&(this.position=t.size),void(this.file=t);throw new d(...M("truncate requires a size argument"))}}e=new de([e]);let i=this.file;const r=i.slice(0,this.position),s=i.slice(this.position+e.size);let o=this.position-r.size;o<0&&(o=0),i=new S([r,new Uint8Array(o),e,s],i.name),this.size=i.size,this.position+=e.size,this.file=i}close(){if(this.fileHandle._deleted)throw new d(...b);this.fileHandle._file=this.file,this.file=this.position=this.size=null,this.fileHandle.onclose&&this.fileHandle.onclose(this.fileHandle)}}class D{constructor(e="",t=new S([],e),i=!0){this._file=t,this.name=e,this.kind="file",this._deleted=!1,this.writable=i,this.readable=!0}async getFile(){if(this._deleted)throw new d(...b);return this._file}async createWritable(e){if(!this.writable)throw new d(...we);if(this._deleted)throw new d(...b);const t=e.keepExistingData?await this.getFile():new S([],this.name);return new X(this,t)}async isSameEntry(e){return this===e}async _destroy(){this._deleted=!0,this._file=null}}class O{constructor(e,t=!0){this.name=e,this.kind="directory",this._deleted=!1,this._entries={},this.writable=t,this.readable=!0}async*entries(){if(this._deleted)throw new d(...b);yield*Object.entries(this._entries)}async isSameEntry(e){return this===e}async getDirectoryHandle(e,t){if(this._deleted)throw new d(...b);const i=this._entries[e];if(i){if(i instanceof D)throw new d(...Y);return i}if(t.create)return this._entries[e]=new O(e);throw new d(...b)}async getFileHandle(e,t){const i=this._entries[e],r=i instanceof D;if(i&&r)return i;if(i&&!r)throw new d(...Y);if(!i&&!t.create)throw new d(...b);return!i&&t.create?this._entries[e]=new D(e):void 0}async removeEntry(e,t){const i=this._entries[e];if(!i)throw new d(...b);await i._destroy(t.recursive),delete this._entries[e]}async _destroy(e){for(let t of Object.values(this._entries)){if(!e)throw new d(...ue);await t._destroy(e)}this._entries={},this._deleted=!0}}const ye=new O("");var I=Object.freeze({__proto__:null,Sink:X,FileHandle:D,FolderHandle:O,default:()=>ye});export{g as FileSystemDirectoryHandle,k as FileSystemFileHandle,A as FileSystemHandle,F as FileSystemWritableFileStream,be as getOriginPrivateDirectory,fe as showDirectoryPicker,pe as showOpenFilePicker,me as showSaveFilePicker};
